# where are we?



# what's here?



# to move around:  cd stands for "change directory" (a directory is a folder)
#    # intro_first    would move into the intro_first folder
#    # .. moves "up" to the containing directory
#    # .  doesn't move at all:  .  represents the current directory    

# for now, let's not move anywhere



# we will use a few file-handling "system" libraries. 
# these are built-in to python, so nothing to install - just to import:
import os
import os.path


#
# in fact, we can read it - it's just not a .ipynb file!
#
# try it here, for your system:

print("+++ contents of the file nottrue.ipynb: +++\n")

# mac:    !cat  <filepath>  using forward slashes
#
# !cat ./intro_first/nottrue.ipynb       

# windows:  type <filepath>  using backslashes
#
# !type .\\intro_first\\nottrue.ipynb       


#
# function to return the contents of a file (as one-big-string)
#

def get_string_from_file(filename_as_string):
    """ return all of the contents from the file, filename
        will error if the file is not present, then return the empty string ''
    """
    try:
        # the encoding below is a common default, but not universal...
        file_object = open(filename_as_string, "r", encoding='utf-8')    # open! (other encodings: 'latin-1', 'utf-16', 'utf-32') 
        file_data = file_object.read()                                   # and get all its contents
        file_object.close()                                              # close the file (optional)
        #print(data)                                                     # if we want to see it
        return file_data                                                 # definitely want to return it!
    except filenotfounderror:                             # it wasn't there
        print(f"file not found: {filename_as_string}")    # print error
        return ''                                         # return empty string ''
    except unicodedecodeerror:
        print(f"decoding error: {filename_as_string}")    # encoding/decoding error  
        return ''                                         # return empty string ''


full_file_path = "./intro_first/nottrue.ipynb"
file_contents = get_string_from_file(full_file_path)      # reminder: file_contents = file_data from above

# let's print only some of this potentially large string, adapting as needed:
print("file_contents:\n\n", file_contents[0:42])          # let's then increase the 42...


####  let's try one of the other files!  (or a non-existent file!)

full_file_path = "./intro_first/cs/file35.txt"    # how about the others?!
file_contents = get_string_from_file(full_file_path)     
print("file_contents:\n\n", file_contents[0:42])


#
# steppingstone, version 0: does python work?
#

import os
import os.path

def file_walker(path):
    """ starting from the input, named path
        
        this function "walks" the whole path, including subfolders
        and then... explores any questions we might want :)

        call, for example, with    file_walker("./intro_first") 
    """
    return 42  # just to check that it's working (v0)    

#
# when discovering, keep your data close (and your functions closer!)
#
if true:
    """ overall script that runs examples """
    print(f"[[ start! ]]\n")     # sign on

    path = "./intro_first"       # remember: . means the current directory
    result = file_walker(path)   # run!

    print(f"result = {result}")  # yay for f-strings!

    print("\n[[ fin. ]]")        # sign off



# os.walk returns the structure of a folder (directory)

# here, we "walk" the intro_examples subfolder:
all_files = os.walk("./intro_first")

all_files     # oops! it's a "generator object"


import os
l = list( os.walk( "./intro_first" ) )  
print(f"{len(l) = }")
print(f"{l = }")


from ipython import display
#
# this is in the hw1pr1 folder
#
display.image("./intro_first_ss_small.png")   # local image


path = "./intro_first"          # any path to any folder
result = list(os.walk(path))    # this will "walk" all of the subfolders and files

print(f"{len(result) = }")      # try c:/  (it took my machine 12.7 seconds!)
print(f"{result = }")


#
# steppingstone, version 1: call os.walk, return length, optionally print
#

import os
import os.path

def file_walker(path):
    """ starting from the input, named path
        
        this function "walks" the whole path, including subfolders
        and then... explores any questions we might want :)

        call, for example, with    file_walker("./intro_first") 
    """
    result = list(os.walk(path))     # perhaps try w/o converting to a list...
    # print(f"{len(result) = }")
    # print(f"{result = }")
    num_folders = len(result)        # the len is the number of folders...
    return num_folders

#
# when discovering, keep your data close (and your functions closer!)
#
if true:
    """ overall script that runs examples """
    print(f"[[ start! ]]\n")     # sign on

    path = "./intro_first"       # remember: . means the current directory
    result = file_walker(path)   # run!

    print(f"result = {result}")  # yay for f-strings!

    print("\n[[ fin. ]]")        # sign off



#
# steppingstone, version 2: print all of the folder names!
#

import os
import os.path

def file_walker(path):
    """ starting from the input, named path
        
        this function "walks" the whole path, including subfolders
        and then... explores any questions we might want :)

        call, for example, with    file_walker("./intro_first") 
    """
    result = list(os.walk(path))     # perhaps try w/o converting to a list...

    for folder_tuple in result:
        currentpath, subfolders, files = folder_tuple  # always three items, always these...
        print(f"{currentpath = }")   # try non-f printing: it's worse!

    num_folders = len(result)        # the len is the number of currentpaths...
    return num_folders

#
# when discovering, keep your data close (and your functions closer!)
#
if true:
    """ overall script that runs examples """
    print(f"[[ start! ]]\n")     # sign on

    path = "./intro_first"       # remember: . means the current directory
    result = file_walker(path)   # run!

    print(f"result = {result}")  # yay for f-strings!

    print("\n[[ fin. ]]")        # sign off



#
# steppingstone, version 3: walk all of the files, printing each one's fullpath
#

import os
import os.path

def file_walker(path):
    """ starting from the input, named path
        
        this function "walks" the whole path, including subfolders
        and then... explores any questions we might want :)

        call, for example, with    file_walker("./intro_first") 
    """
    result = list(os.walk(path))     # perhaps try w/o converting to a list...

    for folder_tuple in result:
        currentpath, subfolders, files = folder_tuple  # always three items, always these...

        if '__macosx' in currentpath: continue         # skip the rest of _this_ loop iteration: back to top

        print(f"{currentpath = }") 
        
        for file in files:       # remember, files is a list of filenames!
            fullpath = currentpath + "/" + file           # construct the full path, or, better: os.path.join(currentpath,file)  
            print(f"   {fullpath = }")
            #contents = get_string_from_file(fullpath)     # use the fullpath!
            #print(f"{contents[0:42] = }")

    num_folders = len(result)        # the len is the number of currentpaths...
    return num_folders

#
# when discovering, keep your data close (and your functions closer!)
#
if true:
    """ overall script that runs examples """
    print(f"[[ start! ]]\n")     # sign on

    path = "./intro_first"       # remember: . means the current directory
    result = file_walker(path)   # run!

    print(f"result = {result}")  # yay for f-strings!

    print("\n[[ fin. ]]")        # sign off



os.path.join("/root/users/secret_stuff" , "file_name")


#
# steppingstone, version 4: walk all of the files, printing (bits of) each one's contents!
#

import os
import os.path

def file_walker(path):
    """ starting from the input, named path
        
        this function "walks" the whole path, including subfolders
        and then... explores any questions we might want :)

        call, for example, with    file_walker("./intro_first") 
    """
    result = list(os.walk(path))     # perhaps try w/o converting to a list...

    for folder_tuple in result:
        currentpath, subfolders, files = folder_tuple  # always three items, always these...
        if '__macosx' in currentpath:  continue
        print(f"{currentpath = }") 

        for file in files:       # remember, files is a list of filenames!
            if file.startswith("."):  # skip files that start with a dot
                continue

            fullpath = currentpath + "/" + file           # construct the full path, or, better: os.path.join(currentpath,file)  
            print(f"   {fullpath = }")

            contents = get_string_from_file(fullpath)     # use the fullpath!
            print(f"   {contents[0:42] = }")

    num_folders = len(result)        # the len is the number of currentpaths...
    return num_folders

#
# when discovering, keep your data close (and your functions closer!)
#
if true:
    """ overall script that runs examples """
    print(f"[[ start! ]]\n")     # sign on

    path = "./intro_first"       # remember: . means the current directory
    result = file_walker(path)   # run!

    print(f"result = {result}")  # yay for f-strings!

    print("\n[[ fin. ]]")        # sign off



#
# rolodex lead-in, example1: counting the number of .txt files...
#

import os
import os.path

def file_walker(path):
    """ starting from the input, named path
        
        this function "walks" the whole path, including subfolders
        and then... explores any questions we might want :)

        call, for example, with    file_walker("./intro_first") 
    """
    result = list(os.walk(path))     # perhaps try w/o converting to a list...
    
    count_txt = 0    # keep count of our .txt files

    for folder_tuple in result:
        currentpath, subfolders, files = folder_tuple  # always three items, always these...
        if '__macosx' in currentpath:  continue
        print(f"{currentpath = }") 

        for file in files:       # remember, files is a list of filenames!
            fullpath = currentpath + "/" + file           # construct the full path, or, better: os.path.join(currentpath,file)  
            print(f"   {fullpath = }")
            if file[0] == ".": continue      # skip files that start with dot
            if file[-4:] == ".txt":
                print("found a .txt file! adding one...")
                count_txt += 1
            #contents = get_string_from_file(fullpath)     # use the fullpath!
            #print(f"   {contents[0:42] = }")

    return count_txt   # phew, we're finally returning something else!

#
# when discovering, keep your data close (and your functions closer!)
#
if true:
    """ overall script that runs examples """
    print(f"[[ start! ]]\n")     # sign on

    path = "./intro_first"       # remember: . means the current directory
    result = file_walker(path)   # run!

    print(f"num txt files = {result}")  # yay for f-strings!

    print("\n[[ fin. ]]")        # sign off



#
# rolodex lead-in, example2: counting the number of .txt files containing 'cs' ...
#

import os
import os.path

def file_walker(path):
    """ starting from the input, named path
        
        this function "walks" the whole path, including subfolders
        and then... explores any questions we might want :)

        call, for example, with    file_walker("./intro_first") 
    """
    result = list(os.walk(path))     # perhaps try w/o converting to a list...
    
    count_txt = 0    # keep count of our .txt files
    count_cs = 0     # keep count of 'cs' substrings found

    for folder_tuple in result:
        currentpath, subfolders, files = folder_tuple  # always three items, always these...
        if '__macosx' in currentpath:  continue
        print(f"{currentpath = }") 

        for file in files:       # remember, files is a list of filenames!
            fullpath = currentpath + "/" + file           # construct the full path, or, better: os.path.join(currentpath,file)  
            print(f"   {fullpath = }")
            if file[0] == ".": continue      # skip files that start with dot

            if file[-4:] == ".txt":
                # print("found a .txt file! adding one...")
                count_txt += 1
                contents = get_string_from_file(fullpath)     # use the fullpath!
                if 'cs' in contents:
                    print("        *** found a 'cs' ... adding 1    (aka 2-true)")
                    count_cs += 1
                # print(f"   {contents[0:42] = }")

    return count_cs, count_txt   # oooh... we can return two things!

#
# when discovering, keep your data close (and your functions closer!)
#
if true:
    """ overall script that runs examples """
    print(f"[[ start! ]]\n")     # sign on

    path = "./intro_first"       # remember: . means the current directory
    result = file_walker(path)   # run!

    count_cs, count_txt = result
    print()
    print(f"num txt files       = {count_txt}")  
    print(f"num containing cs   = {count_cs}")  
    perc = count_cs*100/count_txt
    print(f"for a cs percentage of {perc:5.2f}%")   # :5.2f means width of 5, 2 dec. places, for a _floating pt value

    print("\n[[ fin. ]]")        # sign off



path = "./intro_first"          # any path to any folder?!  intro_first contains _5_ folders total
# path = "./intro_second"       # any path to any folder?!  intro_second contains _12_ folders total
# path = "./files_challenge"    # this is the really large folder: it contains _23_ folders total

# path = "c:/"                  # could use c:/  on windows or "/" on macos  
# path = "."                    # could use "." for the current directory

result = list(os.walk(path))    # this will "walk" all of the subfolders and files

print(f"{len(result) = }")      # this took my machine 2m 47.4s seconds (for "/" with total 555695 folders)
                                # and, it asked for permission a couple of times (i said no.)
#print(f"{result = }")          # let's _not_ print it out...


import os

def count_txtfiles(root_path):
    """count the number of .txt files in a directory (including subdirectories)."""
    txt_count = sum(len([f for f in files if f.endswith('.txt')]) for _, _, files in os.walk(root_path))
    return txt_count

root_folder = "."  
print(f"number of .txt files: {count_txtfiles(root_folder)}")



def max_folder_depth(root_path):
    """find the deepest folder depth in a directory tree."""
    return max(root.count(os.sep) for root, _, _ in os.walk(root_path)) - root_path.count(os.sep)

print(f"max folder depth: {max_folder_depth(root_folder)}")





def extract_digits(s):
    """extract digits from a string."""
    return "".join(re.findall(r"\d", s))

def count_phone_numbers(root_path):
    """count phone numbers based on digit length (7, 10, 11)."""
    phone_counts = {7: 0, 10: 0, 11: 0}

    for root, _, files in os.walk(root_path):
        for file in files:
            if file.endswith('.txt'):
                with open(os.path.join(root, file), 'r', encoding='utf-8') as f:
                    phone_number = extract_digits(f.readline().strip())
                    length = len(phone_number)
                    if length in phone_counts:
                        phone_counts[length] += 1

    return phone_counts

print(count_phone_numbers(root_folder))



def count_909_numbers(root_path):
    """count phone numbers that start with 909."""
    count_909 = 0

    for root, _, files in os.walk(root_path):
        for file in files:
            if file.endswith('.txt'):
                with open(os.path.join(root, file), 'r', encoding='utf-8') as f:
                    phone_number = extract_digits(f.readline().strip())
                    if len(phone_number) == 10 and phone_number.startswith("909"):
                        count_909 += 1

    return count_909

print(f"909 area code numbers: {count_909_numbers(root_folder)}")



def count_names_with_three_i(root_path):
    """count names that contain at least three 'i's."""
    count = 0
    for root, _, files in os.walk(root_path):
        for file in files:
            if file.endswith('.txt'):
                with open(os.path.join(root, file), 'r', encoding='utf-8') as f:
                    f.readline() 
                    name = f.readline().strip()
                    if name.lower().count("i") >= 3:
                        count += 1
    return count

print(f"names with three 'i's: {count_names_with_three_i(root_folder)}")



def count_large_phone_numbers(root_path):
    """count phone numbers with more than 10 digits."""
    count = 0
    for root, _, files in os.walk(root_path):
        for file in files:
            if file.endswith('.txt'):
                with open(os.path.join(root, file), 'r', encoding='utf-8') as f:
                    phone_number = extract_digits(f.readline().strip())
                    if len(phone_number) > 10:
                        count += 1
    return count

print(f"numbers with more than 10 digits: {count_large_phone_numbers(root_folder)}")



import os

def count_last_name(root_path, last_name):
    """count occurrences of a given last name in the dataset."""
    last_name = last_name.lower()
    count = 0

    for root, _, files in os.walk(root_path):
        for file in files:
            if file.endswith('.txt'): 
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    f.readline() 
                    name_line = f.readline().strip().lower()

                    if not name_line:
                        print(f"skipping empty name in {file_path}")
                        continue 

                    if "," in name_line:  
                        extracted_last_name = name_line.split(",")[0].strip()
                    else: 
                        name_parts = name_line.split()
                        if len(name_parts) < 2:
                            print(f"unexpected format in {file_path}: '{name_line}'")
                            continue  
                        extracted_last_name = name_parts[-1] 

                    if extracted_last_name == last_name:
                        count += 1

    return count


root_folder = "./phonebook_data"  


print(f"people with last name 'cs35_participant_4': {count_last_name(root_folder, 'cs35_participant_4')}")
print(f"people with last name 'smith': {count_last_name(root_folder, 'smith')}")



def count_first_name(root_path, first_name):
    """count occurrences of a given first name in the dataset."""
    first_name = first_name.lower()
    count = 0

    for root, _, files in os.walk(root_path):
        for file in files:
            if file.endswith('.txt'): 
                with open(os.path.join(root, file), 'r', encoding='utf-8') as f:
                    f.readline() 
                    name_line = f.readline().strip().lower()
                    
                    if "," in name_line: 
                        extracted_first_name = name_line.split(",")[1].strip()
                    else: 
                        extracted_first_name = name_line.split()[0]

                    if extracted_first_name == first_name:
                        count += 1

    return count

# example usage
print(f"people with first name 'jack': {count_first_name(root_folder, 'jack')}")
print(f"people with first name 'bob': {count_first_name(root_folder, 'emily')}")



def count_numbers_with_42(path):
    count = 0
    for root, _, files in os.walk(path):
        for file in files:
            if file.endswith('.txt'):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    phone_number = extract_digits(f.readline().strip())
                    print(f"checking file: {file_path} | phone: {phone_number}") 
                    if "42" in phone_number:
                        count += 1
    return count

root_folder = "./intro_second"

print(f"numbers containing '42': {count_numbers_with_42(root_folder)}")



from collections import counter
import os

def most_common_first_name(root_path):
    """find the most common first name in the dataset."""
    first_names = counter()
    
    for root, _, files in os.walk(root_path):
        for file in files:
            if file.endswith('.txt'):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    f.readline() 
                    name_line = f.readline().strip()

                    if "," in name_line: 
                        first_name = name_line.split(",")[-1].strip()
                    else:  
                        name_parts = name_line.split()
                        first_name = name_parts[0] if name_parts else none

                    if first_name:
                        first_names[first_name] += 1

    return first_names.most_common(1)[0][0] if first_names else "no valid names found"


root_folder = "./intro_second"


print(most_common_first_name(root_folder))





def count_unique_last_names(root_path):
    """count the number of unique last names in the dataset."""
    unique_last_names = set()
    
    for root, _, files in os.walk(root_path):
        for file in files:
            if file.endswith('.txt'):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    f.readline()  
                    name_line = f.readline().strip()

                    if "," in name_line:  
                        last_name = name_line.split(",")[0].strip()
                    else: 
                        name_parts = name_line.split()
                        last_name = name_parts[-1] if len(name_parts) > 1 else none

                    if last_name:
                        unique_last_names.add(last_name)

    return len(unique_last_names)


root_folder = "./intro_second"


print(f"number of unique last names: {count_unique_last_names(root_folder)}")




import os


def count_total_files(root_path):
    """count the total number of files in a directory and its subdirectories."""
    total_files = sum(len(files) for _, _, files in os.walk(root_path))
    return total_files


def find_deepest_path(root_path):
    """find the deepest path depth in a directory tree."""
    max_depth = 0
    for root, _, _ in os.walk(root_path):
        depth = root[len(root_path):].count(os.sep) 
        max_depth = max(max_depth, depth)
    return max_depth


downloads_folder = "/users/jackyuan/downloads" 


total_files = count_total_files(downloads_folder)
deepest_path = find_deepest_path(downloads_folder)

print(f"total number of files: {total_files}")
print(f"deepest path depth: {deepest_path}")



import os


downloads_folder = "/users/jackyuan/downloads"


def count_screenshot_files(root_path):
    """count the number of files with 'screen shot' in the filename."""
    count = 0
    for root, _, files in os.walk(root_path):
        for file in files:
            if "screen shot" in file:
                count += 1
    return count


def count_pdf_files(root_path):
    """count the number of pdf files in the directory."""
    count = sum(1 for _, _, files in os.walk(root_path) for file in files if file.endswith('.pdf'))
    return count


def find_largest_file(root_path):
    """find the largest file in the directory."""
    largest_file = none
    largest_size = 0
    for root, _, files in os.walk(root_path):
        for file in files:
            file_path = os.path.join(root, file)
            try:
                size = os.path.getsize(file_path)
                if size > largest_size:
                    largest_file = file_path
                    largest_size = size
            except exception:
                pass  

    return largest_file, largest_size


screenshot_count = count_screenshot_files(downloads_folder)
pdf_count = count_pdf_files(downloads_folder)
largest_file, largest_size = find_largest_file(downloads_folder)


print(f"number of screenshot files: {screenshot_count}")
print(f"number of pdf files: {pdf_count}")
print(f"largest file: {largest_file} ({largest_size} bytes)")




