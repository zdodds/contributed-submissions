import requests

url = "https://www.cs.hmc.edu/~dodds/demo.html"
result = requests.get(url)
print(f"{result = }")


# let's print the text we just grabbed:
snack_page = result.text
print(snack_page)

text = snack_page         # ok to have many names...


#    0         1         2             # ten's place
#    0123456789012345678901234567      # one's place
s = "abcdefghijklmnopqrstuvwxy&jk"
s.find("j", 15)                            # try 'a', 'j', 'hi', 'hit', and 'z' ! jk!

                                       # s.find("a",15)   # try ("j",15)



end = 0

while true:
    start = snack_page.find('<li class="snack">', end)
    if start == -1: break     # stop if we're done!
    end = start + 42          # 42 characters!
    
    snack_slice = snack_page[ start:end ]
    print(f"{snack_slice = }")

print("\ncomplete!")



end = 0

while true:
    start = snack_page.find('<li class="snack">', end)
    if start == -1: break     # stop if we're done!
    end = snack_page.find('</li>', start)  # find the correct ending!
    
    snack_slice = snack_page[ start:end+5 ]
    print(f"{snack_slice = }")

print("\ncomplete!")


# we need the length of the search string!
front = len('<li class="snack">')

end = 0

while true:
    start = snack_page.find('<li class="snack">', end)
    if start == -1: break     # stop if we're done!
    end = snack_page.find('</li>', start)  # find the correct ending!
    
    snack_slice = snack_page[ start+front:end ]
    print(f"{snack_slice = }")

print("\nyay!!!")


#
# hw3pr1, part (b)
#

#
# feel free to use this cell - and additional ones...
#

import requests
import re 

url = "https://tsl.news/"
result = requests.get(url)
print(f"{result = }")

# let's print the text we just grabbed:
tsl_page = result.text
print(tsl_page)

text = tsl_page         # ok to have many names...

countpom = len(re.findall(r'pomona', text ))     
countpit = len(re.findall(r'pitzer', text )) 
counthmc = len(re.findall(r'hmc', text )) + len(re.findall(r'harvey mudd', text )) 
countscr = len(re.findall(r'scripps', text )) 
countcmc = len(re.findall(r'cmc', text )) + len(re.findall(r'claremont mckenna', text )) 
print(f'{countpom = }')    
print(f'{countpit = }')  
print(f'{counthmc = }')  
print(f'{countscr = }')  
print(f'{countcmc = }')  

countpp = len(re.findall(r'pomona-pitzer', text )) + len(re.findall(r'p-p', text))  
countcms = len(re.findall(r'cms', text )) + len(re.findall(r'claremont-mudd-scripps', text )) + len(re.findall(r'claremont mudd scripps', text ))
print(f'{countpp = }')  
print(f'{countcms = }') 




# let's import the regular expression library (it should be built-in)
import re


# res are a whole language! 
# let's see a strategic use, to get our snacks from the snack_page above:
import re

m = re.findall(r'<li class="snack">(.*)</li>', snack_page )      # yikes!    common functions: findall, sub, search, match  

print(f"{m = }")                                                 # wow!!!


# let's try some smaller examples to build up to the snack_page example:

# fundamental capabilities:  regex matching and substitution  
#
#    the regex:
#      matcher:    replacer:   in this string:
re.sub(r"harvey",  "mildred",  "harvey mudd")           # the 'r' is for 'raw' strings. they're best for re's.


re.sub(r"car", "cat",  "this car is careful!")          # we'll stick with substitution for now...  uh oh!  space or ,1


re.sub(r"d", "dd", "harvey mud")          # try "mildred mudd"


# anchors:  patterns can be anchored:   $ meand the _end_
re.sub(r"d$", "dd", "mildred mud" )   # $ signifies (matches) the end of the line


# anchors:  patterns can be anchored:   ^  means the _start_ 
re.sub(r"m", "^‚Ñ≥", "mildred mudd" )   # ^ signifies (matches) the start of the line  (unicode m :)


# plus  +   means one or more:
re.sub(r"i+", "i", "isn't the aliiien skiing this weekend? aiiiiiiiiiiiiieee!" )   # try replacing with "" or "i" or "ùíæ" or "‚ìò"


# squarebrackets  [ii]  mean any from that character group:
re.sub(r"[ii]+", "i", "isn't the aliiien skiing this weekend? aiiiiiiiiiiiiieee!" )   # it can vary within the group!


# squarebrackets allow ranges, e.g., [a-z]
re.sub(r"[a-z]", "*", "aha! you've found my secret: 42!")       # use a +,  add a-z, show \w, for "word" character


# let's try the range [0-9] and +
re.sub(r" [0-9]+", " 42",  "aliens <3 pets! they have 45 cats, 6 lemurs, and 789 manatees!")   # discuss!  no +? how to fix?!


re.sub( r"or", "and", "words or phrases" )
re.sub( r"s", "-", "words or phrases" )
re.sub( r"[aeiou]", "-", "words or phrases" )

re.sub( r"$", " [end]", "words or phrases" )
re.sub( r"^", "[start] ", "words or phrases" )

# challenge! the dot . matches _any_ single character:  
re.sub( r".", "-", "words or phrases" )   # what will this do?

re.sub( r".s", "-s", "words or phrases" )  # and this one?!

re.sub( r".+s", "-s", "words or phrases" )  # and this one?!!


# the star (asterisk) matches zero or more times...
re.sub(r"42*", "47", "favorite #'s:  4 42 422 4222 42222 422222")       # try + {2}  {1,3}   (42)


re.sub(r'a', '-', 'alabama')
re.sub(r'a', '', 'alabama')
re.sub(r'o', '-', 'google')
re.sub(r'o+', '-', 'google')
re.sub(r'^o+', '-', 'google')
re.sub(r'a.a', 'a-a', 'alabama')
re.sub(r'a.*a', 'a-a', 'alabama')
re.sub(r'o*', '-', 'google')


m = re.findall(r'<li class="snack">(.*)</li>', snack_page )   # parens are a "capture group"   # try w/o it  # try search & sub
                                                   # each set of parents "captures" the text inside it
print(f"{m = }")                                   # it can even be used later, as \1, \2, \3, etc. 


#
# here is a code cell, with the entire first-draft markdown of the previous cell 
# 
# stored in the python variable      original_markdown
#

original_markdown = """

# claremont's colleges - markdown version

the claremont colleges are a *consortium* of **five** socal institutions. <br>
we list them here.

## the 5cs: a list
+ [pomona](https://www.pomona.edu/)
+ [cmc](https://www.cmc.edu/)
+ [pitzer](https://www.pitzer.edu/)
+ [scripps](https://www.scrippscollege.edu/)
+ [hmc](https://www.hmc.edu/)

the above's an _unordered_ list.  <br>
at the 5cs, we all agree there's __no__ order!

---

## today's featured college: [cmc](https://coloradomtn.edu/)

<img src="https://ygzm5vgh89zp-u4384.pressidiumcdn.com/wp-content/uploads/2017/06/gws_campusview_1000x627.jpg" height=160>

---

### also featured: &nbsp; scripps and pitzer and mudd and pomona

<img src="https://i0.wp.com/tsl.news/wp-content/uploads/2018/09/scripps.png?w=1430&ssl=1" height=100px> &nbsp; 
<img src="https://upload.wikimedia.org/wikipedia/commons/f/f9/brant_clock_tower%2c_pitzer_college%2c_2016_%28cropped%29.jpg" height=100px> &nbsp; 
<img src="https://www.hmc.edu/about/wp-content/uploads/sites/2/2020/02/campus-gv.jpg" height=100px> &nbsp;
<img src="https://upload.wikimedia.org/wikipedia/commons/4/46/smith_tower_and_the_san_gabriel_mountains.jpg" height=100px>

are there _other_ schools in claremont?

### claremont destinations
+ _pepo melo_, a fantastic font of fruit!
+ **starbucks**, the center of claremont's "city," not as good as scripps's _motley_ 
+ ***sancho's tacos***, the village's newest establishment
+ ~~in-and-out cs35_participant_3~~ (not in claremont, alas, but close! cmc-supported!)
+ `42`nd street bagel, an hmc fave, definitely _well-numbered_
+ trader joe's, providing fuel for the walk back to pitzer _from trader joe's_

---

#### regular expression code-of-the-day 
`import re`               
`pet_statement = re.sub(r'dog', 'cat', 'i <3 dogs')`

#### new construction of the ~~day~~ _decade_!

<img src="https://www.cs.hmc.edu/~dodds/roberts_uc.png" height=150> <br><br>

cmc's **_roberts science center_, also known as _"the rubiks cube"_** <br>
currently under construction, under deadline, and undeterred by socal sun, or rain... 

testing the additional \*asterisk\* vs *italics* feature... and the \_underscore\_ vs _italics_ feature... 

<br><br>


"""


#
# here is a function to write a string to a file (default name: output.html)
#

def write_to_file(contents, filename="output.html"):
    """ writes the string final_contents to the file filename """
    f = open(filename,"w")
    print(contents, file=f)
    print(f"{filename = } written. try opening it in a browser!")
    f.close()


#
# let's write our original_markdown to file...
#

write_to_file(original_markdown)


# here is a function to change markdown to markup
#
import re

def handle_down_to_up(contents):
    """ replace all instances of markdown with markup """
    new_contents = re.sub(r"markdown", r"markup", contents)  # simple substitution
    return new_contents

# let's test this!
if true:
    old_contents = "this is markdown text"
    new_contents = handle_down_to_up(old_contents) 
    print(new_contents)



# here is a function to handle blank lines (making them <br>)
#
import re

def handle_newlines(contents):
    """ replace all of the just-newline characters \n with html newlines <br> """
    newlines = []
    oldlines = contents.split("\n")

    for line in oldlines:
        new_line = re.sub(r"^\s*$", r"<br>", line)  # if a line has only space characters, \s, we make an html newline <br>
        newlines.append(new_line)

    new_contents = "\n".join(newlines)   # join with \n characters so it's readable by humans
    return new_contents


# let's test this!
if true:
    old_contents = """
# title
    
# another title"""
    new_contents = handle_newlines(old_contents)
    print(new_contents)


# here is a function to handle headers - right now only h1 (top-level)
#
import re

def handle_headers(contents):
    """ replace all of the #, ##, ###, ... ###### headers with <h1>, <h2>, <h3>, ... <h6> """
    newlines = []
    oldlines = contents.split("\n")

    for line in oldlines:
        new_line = re.sub(r"^#{6} (.*)$", r"<h6>\1</h6>", line) # capture the contents and wrap with <h1> and </h1>
        if new_line == line: # aha! you will be able to handle the other headers here!
            new_line = re.sub(r"^#{5} (.*)$", r"<h5>\1</h5>", line)
        if new_line == line: 
            new_line = re.sub(r"^#{4}(.*)$", r"<h4>\1</h4>", line)
        if new_line == line: 
            new_line = re.sub(r"^#{3} (.*)$", r"<h3>\1</h3>", line)
        if new_line == line:
            new_line = re.sub(r"^#{2} (.*)$", r"<h2>\1</h2>", line)
        if new_line == line:
            new_line = re.sub(r"^# (.*)$", r"<h1>\1</h1>", line)
        newlines.append(new_line)

    new_contents = "\n".join(newlines)   # join with \n characters so it's readable by humans
    return new_contents

# let's test this!
if true:
    old_contents = """
# title
<br>
## another title
### and another!
#### and yet another? 
##### and another!
###### and one last one!"""
    new_contents = handle_headers(old_contents)
    print(new_contents)


# here is a function to handle code - using markdown backticks
#
import re

def handle_code(contents):
    """ replace all of the backtick content with <code> </code> """
    newlines = []
    oldlines = contents.split("\n")

    for line in oldlines:
        new_line = re.sub(r"`(.*)`", r"<tt>\1</tt>", line)  # capture the contents and wrap with <code> and </code>
        newlines.append(new_line)

    new_contents = "\n".join(newlines)   # join with \n characters so it's readable by humans
    return new_contents

# let's test this!
if true:
    old_contents = """\
this is <tt>42</tt>   
<br> 
our regex library:  <tt>import re</tt>"""
    new_contents = handle_code(old_contents)
    print(new_contents)


import re

def handle_bold(contents): 
    """ replace all of the bold content (__bold__ or **bold**) with <b> </b> """
    newlines = []
    oldlines = contents.split("\n")

    for line in oldlines:
        new_line = re.sub(r"__(.*)__", r"<b>\1</b>", line)  # capture the contents and wrap with <code> and </code>
        new_line2 = re.sub(r"\*\*(.*)\*\*", r"<b>\1</b>", new_line)
        newlines.append(new_line2)

    new_contents = "\n".join(newlines)   # join with \n characters so it's readable by humans
    return new_contents

# let's test this!
if true:
    old_contents = """\
this is **42**   
<br> 
our regex library:  <tt>import re</tt>
this is __another bold__"""
    new_contents = handle_bold(old_contents)
    print(new_contents)



import re

def handle_italics(contents): 
    """ replace all of the italic content (_bold_ or *bold*) with <i> </i> """
    newlines = []
    oldlines = contents.split("\n")

    for line in oldlines:
        if "img" in line:
            newlines.append(line)
            continue

        # find escaped underscores or asterisks (e.g., \_italic\_ or \*italic\*) (helped by chatgpt here, kept my initial work which was similar but not quite there...)
        escaped_asterisks = re.findall(r'\\\*(.*?)\\\*', line)
        escaped_underscores = re.findall(r'\\_(.*?)\\_', line)

        # first, remove the escaped asterisks and underscores from the line temporarily
        line_without_escaped = re.sub(r'\\\*(.*?)\\\*', r'\1', line)
        line_without_escaped = re.sub(r'\\_(.*?)\\_', r'\1', line_without_escaped)

        # replace actual italicized text with <i></i> tags
        line_with_asterisks = re.sub(r'(\w|^)\*(.*?)\*(\w|$)', r'\1<i>\2</i>\3', line_without_escaped)
        line_with_underscores = re.sub(r'(\w|^)_(.*?)_(\w|$)', r'\1<i>\2</i>\3', line_with_asterisks)

        # reinsert the escaped asterisks and underscores back into the line (no backslashes should be added)
        for e in escaped_asterisks:
            line_with_underscores = line_with_underscores.replace(e, r'*' + e + r'*')

        for e in escaped_underscores:
            line_with_underscores = line_with_underscores.replace(e, r'_' + e + r'_')

        # append the processed line to the final result
        newlines.append(line_with_underscores)

    new_contents = "\n".join(newlines)   # join with \n characters so it's readable by humans
    return new_contents

        
        # returnline = []

        # for i in range(len(line_with_underscores)):
        #     returnline += line_with_underscores[i] 
        #     for e in escaped_asterisks:
        #         if line_with_underscores[i:i+len(e)] == e:
        #             if i > 0 and (i+len(e)) < len(line_with_underscores):
        #                 if i-1 != '>':
        #                     returnline += line_with_underscores[i] + '*' + line_with_underscores[i:i+len(e)] + '*'
        #                     i = i + len(e)
        # return returnline



        #astorit = re.findall(r"(\w|^)\*(.*?)\*(\w|$)", r"\1<i>\2</i>\3", line)  
        #undorit = re.findall(r"(\w|^)_(.*?)_(\w|$)", r"\1<i>\2</i>\3", line)
        #for e in astorit and not in asterisklist: 
        #re.sub(f'e', )

        #newlines.append(new_line2)


    new_contents = "\n".join(newlines)   # join with \n characters so it's readable by humans
    return new_contents


# re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')
# ['foot', 'fell', 'fastest']
# re.findall(r'(\w+)=(\d+)', 'set width=20 and height=10')
# [('width', '20'), ('height', '10')]


# let's test this!
line = """\
this is *48* and \*48\*
and another *italics!!* and _another_
but \_this\_ shouldn't _count_...
"""

print("original line:")
print(line)

# call the function and print the result
result = handle_italics(line)
print("\nafter processing:")
print(result)

# astorit = re.findall(r"\*(.*?)\*", line)
# print(astorit)
# undorit = re.findall(r"(_(.*?)_)",  line)
# print(undorit)
# asterisklist = re.findall(r'\\\*.*?\\\*', line)
# print(asterisklist)
# underlist = re.findall(r'\\_.*?\\_', line)
# print(underlist)


    



import re

def handle_strikethrough(contents): 
    """ replace all of the bold content (__bold__ or **bold**) with <b> </b> """
    newlines = []
    oldlines = contents.split("\n")

    for line in oldlines:
        new_line = re.sub(r"~~(.*)~~", r"<s>\1</s>", line)  # capture the contents and wrap with <code> and </code>
        newlines.append(new_line)

    new_contents = "\n".join(newlines)   # join with \n characters so it's readable by humans
    return new_contents

# let's test this!
if true:
    old_contents = """\
this is ~~42~~   
<br> 
our regex library:  <tt>import re</tt>
this is ~~another bold~~"""
    new_contents = handle_strikethrough(old_contents)
    print(new_contents)



def handle_list(contents):
    """ all content preceded by a + character will be surrounded by square brackets as a one element list"""
    newlines = []
    oldlines = contents.split("\n")

    for line in oldlines:
        new_line = re.sub(r"\+ (.*$)", r'[\1]', line)  # capture the contents and wrap with <code> and </code>
        newlines.append(new_line)

    new_contents = "\n".join(newlines)   # join with \n characters so it's readable by humans
    return new_contents

contents = '+ aslfkjdskfj askdfj '
print(contents)
print(handle_list(contents))


def handle_url(contents):
    """ adjust url formattin from [name](url) to <a href = 'url'>name</a>"""
    newlines = []
    oldlines = contents.split("\n") 

    for line in oldlines:
        new_line = re.sub(r"\[(.*)\]\((.*)\)", r'<a href="\2">\1</a>', line)  # capture the contents and wrap with <code> and </code>
        newlines.append(new_line)

    new_contents = "\n".join(newlines)   # join with \n characters so it's readable by humans
    return new_contents

contents = original_markdown
print(contents)
#print(handle_url(contents))
#print(re.sub("\", "fds", contents))
print(handle_url(contents))

# [google](https://www.google.com) 
# becomes       <a href="https://www.google.com">google</a>
# you'll have to use two capture groups  (.*?)   which become \1 and \2



def handle_color(contents):
    """ change school names to be written in school colors """
    newlines = []
    oldlines = contents.split("\n")

    for line in oldlines:
        if "img" in line:
            newlines.append(line)
            continue
        new_line = re.sub(r'cmc', r'<span style = "color:maroon;">cmc</span>', line)  
        new_line1 = re.sub(r'pomona', r'<span style = "color:blue;">pomona</span>', new_line)
        new_line2 = re.sub(r'pitzer', r'<span style = "color:orange;">pitzer</span>', new_line1)
        new_line3 = re.sub(r'scripps', r'<span style = "color:seagreen;">scripps</span>', new_line2)
        new_line4 = re.sub(r'hmc', r'<span style = "color:goldenrod;">hmc</span>', new_line3)
        new_line5 = re.sub(r'mudd', r'<span style = "color:goldenrod;">mudd</span>', new_line4)
        newlines.append(new_line5)

    new_contents = "\n".join(newlines)   # join with \n characters so it's readable by humans
    return new_contents

contents = 'abc cmc abc hmc'
print(contents)
#print(handle_url(contents))
#print(re.sub("\", "fds", contents))
print(handle_color(contents))    

#color example:  <span style="color:dodgerblue;">go dodgers!</span>
#bckgd example:  <span style="background:coral;">go dodgers!</span>


#
# overall mardown-to-markup transformer
#

contents_v0 = original_markdown              # here is the input - be sure to run the functions, below:

contents_v1 = handle_down_to_up(contents_v0)   #   blank lines to <br>
contents_v2 = handle_newlines(contents_v1)   #   blank lines to <br>
contents_v3 = handle_headers(contents_v2)    #   # title to <h1>title</h1>  (more needed: ## to <h2>, ... up to <h6>)
contents_v4 = handle_code(contents_v3)       #   `code` to <tt>code</tt>
contents_v5 = handle_bold(contents_v4) # **bold** or __bold__ to <b>bold</b>
contents_v6 = handle_italics(contents_v5) # *italics* or _italics_ to <i>italics</i>
contents_v7 = handle_strikethrough(contents_v6) # ~~strikethrough~~ to <s>strikethrough</s>
contents_v8 = handle_list(contents_v7) # handle lists! 
contents_v9 = handle_url(contents_v8) # handle urls!
contents_v10 = handle_color(contents_v9) # changes school colors 
final_contents = contents_v10         # here is the output - be sure it's the version you want!

write_to_file(final_contents, "output.html") # now, written to file:  reload it in your browser!



# we can also print the final output's source - this should show the html (so far)
print(final_contents)    
# in addition, _do_ open up output.html in your browser and then view source to see the same html (so far)


