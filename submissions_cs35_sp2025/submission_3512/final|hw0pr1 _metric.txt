#
# python is a popular language for executable expression
#     this is a python cell
#     try this shortcut: control-return or control-enter runs it:

x = 43
print("x is", x)

x -= 1

# notice that the last expression is the cell's output.
# printing and outputting are different!


#
# let's fit all of python into the next five or so cells!
#

l = [7,8,9]

print("l[1:] equals", l[1:])    # slicing!

print(f"l[1:] equals {l[1:]}")  # f strings!

print(f"{l[1:] = }")            # cool = syntax, new for me...

print()

colleges = 'cmc scripps pitzer hmc'
print(colleges)

'c' in colleges          # in is in!


x = 42

print("x =", x)    # "regular" print

print(  f"{x = }" )  # f-string print


"""wrong = 41"""
snack = "poptarts"

# fs = f"{snack}? i'll take {wrong+1}!"
# print(fs)

for i in range(40,42+1):
    print(f"{snack}? i'll take {i}!")



print(f"{l=}  l.index(9) is", l.index(9))     # calling methods (functions after a ".")
print()
print("colleges.title() returns ", colleges.title())        # ditto!  let's shout!
print()
print("# of c's in colleges:", colleges.count('c'))
print()
print(colleges.replace('c','c'))


low = colleges.split()
print("low is", low)

los = colleges.split('c')
print("los is", los)


low = [ "word", "leisa", "we", "some" ]
''.join(low)


#
# f-strings!
#

interface = "jupyter"
language = "python"
application = "vscode"

#unrelated experimenting :)
l = [interface, language, application]
lstring = ''.join(l)

nop = lstring.split('p')

print(f"nop is {nop}")

day = "monday"
family = "sister"
age = 15

print(f"next {day} my {family} turns {age}")
print()

#company = "meta"
#print(f"{company} would be proud!")

#
# feel free to create your own quippy example here or in a new cell...
#


# i <3 list comprehensions!
[ 2*x for x in range(20,24) ]


#
# here is an example that uses list comprehensions to
# count how many of the first 1000 integers are even

lc = [ x for x in range(1000) if x % 2 == 0 ]
print(f"lc = {lc}")
print()

answer = len(lc)
print(f"answer = {answer}")



l = [x**2 for x in range(1000) if '4' in str(x**2)]

print(f"{len(l)} of the first 1000 integers, squared, contain the digit 4")
print()

l = [x**2 for x in range(1000) if '2' in str(x**2)]
print(f"{len(l)} of the first 1000 integers, squared, contain the digit 2")
print()

l = [x**2 for x in range(1000) if '4' in str(x**2) or '2' in str(x**2)]
print(f"{len(l)} of the first 1000 integers, squared, contain the digit 4 or 2")


# remember pwd? it's short for "print working directory"  (that is, your current folder)
# it's a shell command, i.e., to be run at the terminal or command-line (or shell).

# since this is not python, python needs to know it's a special command:  # does the trick



# another important shell command:  ls (lists contents)



# the following cell shows cd, changing the current directory.
# we will also try # (to "move up" one level)

# warning:  when cd does work, the _whole notebook_ has changed what it considers
#           its "current directory"  you'll see this here:



# and, we need to be able to move "up" or "outward"!
# to do this, use   #     here, in jupyter:




# we can keep going!   # "goes up" one directory level



# you don't need a new cell each time...



# really, each notebook cell is a script, sharing state with the others

# here, our code is guarded by an if true:

if false:
    print(f"it was false!")

# try changing the true to false.
# there's no need to change the printing, because it won't print...

# when submitting notebooks, we ask you to submit notebooks that run...
# however, feel free to keep any+all non-running code! simply comment it out
# for example, with if false:
# hashtags and """ triple-quoted strings """ also work ...
# ... though they lose the code-structure and syntax highlighting! (as you see! :-)


# reminder: in each cell (script) all lines are run; only the last line is output
y = 58
x = y-7
x = x-1
x = x-8



# beware:  variables are global through the notebook!
# here, y will be 58, from the cell above... if you've run that cell!



# a good starting point!

def plus1( n ):
    """ returns a number one larger than its input """
    return n+1

if true:
    print(f"plus1(41) -> {plus1(41)} should be {42}")
    print(f"plus1(9000) -> {plus1(9000)} should be {9001}")
    assert plus1(41) == 42
    assert plus1(9000) == 9001

# print tests succeed and fail "out loud"
# assert tests succeed silently and only fail "out loud" (and crash!)


#
# an infinite loop...
#

print(f"start!")
i = 0

while true:
    print(i, end=" ", flush=true)
    i = i+1

print(f"end.")



#
# let's loop!
#

snack = "poptarts"

for i in range(0,5):
        print(f"{snack}? i'll take {i}!")


# countdown( n )    emphasizes looping and printing (there is no return value!)
#
import time

def countdown( n ):
    """ counts downward from n to 0, printing  """
    for i in range(n,-1,-1):  # starts at n, ends at 0, steps by -1
        print("i ==", i)
        time.sleep(0.2)

    return    # no return value here!

# testing countdown
if true:
    print("testing countdown(5):")
    countdown(5)  # should print things -- with dramatic pauses!


if true:
    """ a cell for trying out the previous two cells """

    # sign on
    print(f"[[ start! ]]\n")

    # testing plus1
    result = plus1( 41 )
    print(f"plus1(41) -> {result}")
    print()

    # testing countdown
    print("testing countdown(4):")
    countdown(4)  # should print things -- with dramatic pauses!

    # sign off
    print("\n[[ fin. ]]")


def mystery1( s ):
    """ mystery function #1 """
    result = 0

    for i in range(len(s)):
        if s[i] in 'ii':
            result += 1

    return result

result = mystery1("aliens <3 caffeine")
print(result)


def mystery2( s ):
    """ mystery function #2 """
    result = 0

    for let in s:
        if let in 'ii':
            result += 1

    return result

result = mystery2("i like caffeine")
print(result)


def count_eyes( s ):
    """ returns the number of times i or i appears in the input string s """
    result = 0

    for letter in s:
        if letter in 'ii':  #  equivalent:   letter == 'i' or letter == 'i'
            result += 1     #  add one to our overall result (our count)

    return result           #  after the loop, we're done!

print("count_eyes('yiiikes!') =",count_eyes('yiiikes!'))
print(f"{count_eyes('yiiikes!') = }")   # f-strings ⋮)
print()
print(f"{count_eyes('italy, icily, livelily!') = }")


def just_eyes( s ):
    """ returns a string of only the letters i or i that appear in the input s """
    result = ''

    for letter in s:
        if letter in 'ii':    #  equivalent:   letter == 'i' or letter == 'i'
            result += letter  #  add _the letter_ to our overall result, now a string

    return result             #  after the loop, we're done!

print("just_eyes('yiiikes!') =",just_eyes('yiiikes!'))
print(f"{just_eyes('yiiikes!') = }")   # f-strings ⋮)
print()
print(f"{just_eyes('italy, icily, livelily!') = }")


def get_string_from_file(filename=none):
    """ return all of the contents from the file, filename
        will error if the file is not present, then return the empty string ''
    """
    try:
        if filename == none:  filename = "input.txt"
        input_filename = filename
        input_file = open(input_filename, "r", encoding='utf-8')    # how to open a file
        data = input_file.read()                                    # and get all its contents
        input_file.close()                                          # close the file (optional)
        #print(data)                                                # if we want to see it
        return data                                                 # definitely want to return it!
    except filenotfounderror:                   # wasn't there
        print(f"file not found: {filename}")    # print error
        return ''                               # return empty string ''

# split is a wonderful function, it returns a list.  try it!
input_string = get_string_from_file("input.txt")

# let's print only some of this large string, with all of shakespeare's sonnets:
print(input_string[0:200])



input_string = get_string_from_file("input.txt")
input_list = input_string.split("\n")  # '\n'

for s in input_list:                   # let's test it on each string (line) in our list
    inp = s                            # the input
    out = count_eyes(inp)              # the output
    # print(f"{inp} -> {out}")           # print result
    print(f"{inp:>50s} -> {out:<d}")   # f-strings have formatting options: (> right) (< left)


input_string = get_string_from_file("input.txt")
input_list = input_string.split("\n")  # '\n'

allresults = []

for s in input_list:                   # let's test it on each string (line) in our list
    inp = s                            # the input
    out = count_eyes(inp)              # the output
    # print(f"{inp} -> {out}")           # print result
    print(f"{inp:>50s} -> {out:<d}")   # f-strings have formatting options: (> right) (< left)
    allresults.append( [out,inp] )       # append the output and input as a _sublist_

maximum_line = max(allresults)          # take the maximum
print("the max and maximum line:", maximum_line)


#
# using python's string library
#

import string

print(string.digits)
print(string.punctuation)
print(string.ascii_lowercase)


# plus1, countdown, count_eyes, and just_eyes are already complete :-)


#
# times42( s ):      	which should print the string s 42 times (on separate lines)
#

def times42( s ):
   
    i = 0
    for i in range(0,42): #loops 42 times
        print(s)  #prints one string per loop
        i+=1 
    return          

times42("hi")



#had a misunderstanding with range, and thought that setting range 0,4 would give me 5 iterations


def alien( n ):
    int(n)
    eyes = '' #creates variable to fill with string
    for i in range(0,n):
        eyes += 'i' #builds variable up to contain as many "i"s as desired
    print(f"al{eyes}en") #insert variable into word

    return 

alien(5)


#
# count_digits( s ):   returns the number of digits in the input string s
#

def count_digits( s ):
    count = 0
    for i in s: #iterates through each string character
        if i.isdigit(): #is the char a digit?
            count+=1 #if so, count it
    return count 

count_digits("1h3b59")


#
# just_digits( s ):   returns only the digits in the input string s
#

def just_digits( s ):
    jd = '' #create an empty string to fill
    for i in s: #iterates through each string character
        if i.isdigit():
            jd+=i #adds that character to jd if it is a digit
    return jd 

just_digits("1uv8324-y971g34ui")


# my original code cut out spaces and made everything lowercase, but i didn't know how to cut out symbols.
# then i realized that instead of cutting out what i didn't want, i could just pick out what i did want

def just_text( s ):
    print(f"here is your modified sentence: ")

    news = '' #empty string
    for i in s:
        if i.isalpha(): #if character in string is a letter
            news += i.lower() #then lowercase it, and add to string

    return news

just_text("hello, my name is cs35_participant_1!")


#
# your own string-transforming function:  up to you
#    the goal: come up with something uniquely yours ...
#              ... no need to go overboard (more challenges ahead!)
#
# be sure to show off at least two of your own tests, too
#

# here's my example:

def poptart_score(s):
    """ returns the wordle score vs. "poptart" (exactly 7 letters)
          $ will represent the correct letter in a correct spot
          ~ will represent the correct letter in an incorrect spot
    """
    # let's make sure s has exactly 7 letters
    s = s + "*"*7   # add extra asterisks at the end to have at least 7 letters
    s = s[0:7]      # trim to 7 letters using a slice

    result = ""
    for i in range(len(s)):  # loop over each index i, from 0 to len(s)-1
        if "poptart"[i] == s[i]:
            result += '$'    # correct letter, correct spot
        elif s[i] in "poptart":
            result += '~'    # correct letter, wrong spot
        else:
            result += ' '    # not a correct letter

    return result

#
# be sure to run on a large string
#
input_string = """scripps claremontmckenna pitzer mudd pomona sci50l poptart"""
input_list = input_string.split()
for s in input_list:              # let's test it on each string (word) in our list
    inp = s                       # the function input
    out = poptart_score(s)       # the function output
    inp7 = (s + "*"*7)[:7]          # a seven-character (padded/sliced) input
    print(f"{inp:>25s}  ->  |{inp7}|")
    print( f"{'':>25s}      |{out}|")      # f-strings to show the transformation
    print( f"{'':>25s}      |{'poptart'}|\n")


#
# also be sure to run on at least one file find the results
#     can be only printing, but if there's something to maximize or minimize,
#     it is always fun to see what's "best" or "worst"
#

input_string = get_string_from_file("input.txt")
input_list = input_string.split("\n")  # '\n'

allresults = []

for s in input_list:              # let's test it on each string (word) in our list
    inp = s                       # the function input
    out = poptart_score(s)       # the function output
    inp7 = (s + "*"*7)[:7]          # a seven-character (padded/sliced) input
    print(f"{inp[0:20]:>25s}  ->  |{inp7}|")
    print( f"{'':>25s}      |{out}|")      # f-strings to show the transformation
    print( f"{'':>25s}      |{'poptart'}|\n")
    this_score = out.count("$")*4 + out.count("~")*2  # my scoring system!
    allresults.append( [out,inp] )       # append the output and input as a _sublist_

maximum_line = max(allresults)          # take the maximum
print("the max and maximum line:", maximum_line)


#
# your own string-transforming function:  up to you
#    encouraged: come up with something uniquely yours (or your team's)
#                ... but no need to go overboard (more problems are ahead!)
#
# be sure to show off a couple of your own tests, too
#

# here's kenneth and charlie's:


def obish(s):
    '''
    input: a string, s
    output: the string converted to obish (https://www.instructables.com/how-to-speak-obish/)
    '''
    vowels = 'aeiouy'
    outputstr = ""
    for i in s:
        if i in vowels:
            outputstr += "ob"
        outputstr += i
    return outputstr

print(obish('bingus'))
print(obish('kenneth goes to my school.'))
print(obish('brb i have to get my laundry'))
assert obish('bingus') == 'bobingobus'
assert obish('kenneth goes to my school.') == 'kobennobeth goboobes tobo moby schoboobol.'
assert obish('brb i have to get my laundry') == 'brb i hobavobe tobo gobet moby lobaobundroby'

#
# note from zd:  not sure what i'd maximize here, but so be it!
#


#madlibs function
import random

def madlib(s):
    l = s.split() #take string input and turn into list
    m = (f"john was going to go to the {l[random.randint(0,3)]} in a {l[random.randint(0,3)]}, but he noticed his {l[random.randint(0,3)]} was replaced by a {l[random.randint(0,3)]}!")  #then have each empty space for a word pick a random index from the list
    return m


n = input("please enter 4 noun, separated by spaces") #someone can enter their own words!

#practice string
#n = 'moon robot dog fish'

madlib(n)


print("let's generate a tic tac toe game")

# tic tac toe function
def tictactoe(s):
    l = s.split() #take two symbol string and turn into list l

    #generate the actual symbols to fill each space:

    ttt = '' #create empty string to fill
    for i in range(0,9): #run loop nine times, tictactoe requires 9 filled spaces
        ttt += str(" " + l[random.randint(0,1)]) #each run adds one symbol or the other from l to string & added spaces allow string to be split into list
        i+=1
    lt = ttt.split() #splits symbol string into list

            
    #now to see if there was a winning pattern or not:

    #my original code... not so good, but with each set not really following a numerical pattern, i couldn't figure out how to condense it
    #winloss = ''
    # if lt[0] == lt[1] == lt[2]:
    #     winloss = 1
    # if lt[3] == lt[4] == lt[5]:
    #     winloss = 1
    # if lt[6] == lt[7] == lt[8]:
    #     winloss = 1
    # if lt[2] == lt[5] == lt[8]:
    #     winloss = 1
    # if lt[1] == lt[4] == lt[7]:
    #     winloss = 1
    # if lt[0] == lt[3] == lt[6]:
    #     winloss = 1
    # if lt[0] == lt[4] == lt[7]:
    #     winloss = 1
    # if lt[2] == lt[4] == lt[6]:
    #     winloss = 1

    #chatgpt helped me out though
    winloss = 0  # default value
    winning_combinations = [
        (0, 1, 2), (3, 4, 5), (6, 7, 8),  # rows
        (0, 3, 6), (1, 4, 7), (2, 5, 8),  # columns
        (0, 4, 8), (2, 4, 6)              # diagonals
    ]
    for a, b, c in winning_combinations:
        if lt[a] == lt[b] == lt[c]:  #if winning combination (in order) is detected
            winloss = 1 #add 1 for win

    print()

    #now to let user see their game:

    #chat also helped me condense this code...
    # print(f"{lt[0]} | {lt[1]} | {lt[2]}")
    # print(f"{lt[3]} | {lt[4]} | {lt[5]}")
    # print(f"{lt[6]} | {lt[7]} | {lt[8]}")

    for i in range(0, 9, 3): #i iterates through range of 9 in steps of 3
        print(f"{lt[i]} | {lt[i+1]} | {lt[i+2]}")

    print()

    if winloss == 1: #if win was detected
        print("win!")
    else: #win was not detected
        print("loss :(")

    return

tictactoe(input("please enter two symbols, separated by a space. the computer will play a game of tic tac toe with these symbols: "))


