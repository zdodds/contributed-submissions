# we assign the url and obtain the api-call result into result
#    note that result will be an object that contains many fields (not a simple string)
#

import requests

url = "http://api.open-notify.org/iss-now.json"   # this is sometimes called an "endpoint" ...
result = requests.get(url)

# if it succeeds, you should see <response [200]>


#
# in this case, we know the result is a json file, and we can obtain it that way:

json_contents = result.json()      # needs to convert the text to a json dictionary...
print(f"json_contents is {json_contents}")     # aha!  let's re/introduce f-strings...

# take a look... remember that a json object is a python dictionary:


#
# let's remind ourselves how dictionaries work:

lat = json_contents['iss_position']['latitude']
lat = float(lat)
print("lat: ", lat)


from math import *
def haversine(lat1, long1, lat2, long2):
    """
    calculate the great circle distance in kilometers between two points
    on the earth (specified in decimal degrees)
    """
    # convert decimal degrees to radians
    long1, lat1, long2, lat2 = map(radians, [long1, lat1, long2, lat2])

    # haversine formula
    dlong = long2 - long1
    dlat = lat2 - lat1
    trig = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlong/2)**2

    # radius of earth. use 3956 for miles. 6371 for km.
    radius = 3956  # we'll use miles!
    return radius * 2 * asin(sqrt(trig))


#
# let's make sure we "unpack the process" w/o ai
#



#
# then, let's compare with ai's result...
#


#
# we assign the url and use requests.get to obtain the result into result_astro
#
#    remember, result_astro will be an object that contains many fields (not a simple string)
#

import requests

url = "http://api.open-notify.org/astros.json"   # this is sometimes called an "endpoint" ...
result_astro = requests.get(url)
result_astro

# if it succeeded, you should see <response [200]>


# if the request succeeded, we know the result is a json file, and we can obtain it that way.
# let's call our dictionary something more specific:

astronauts = result_astro.json()
d = astronauts   # a shorter variable for convenience..


# remember:  astronauts will be a _dictionary_
note = """ here's yesterday evening's result - it _should_ be the same this morning!

{"people": [{"craft": "iss", "name": "oleg kononenko"}, {"craft": "iss", "name": "nikolai chub"},
{"craft": "iss", "name": "tracy caldwell dyson"}, {"craft": "iss", "name": "matthew dominick"},
{"craft": "iss", "name": "michael barratt"}, {"craft": "iss", "name": "jeanette epps"},
{"craft": "iss", "name": "alexander grebenkin"}, {"craft": "iss", "name": "butch wilmore"},
{"craft": "iss", "name": "sunita williams"}, {"craft": "tiangong", "name": "econ176_participant_6 guangsu"},
{"craft": "tiangong", "name": "econ176_participant_6 cong"}, {"craft": "tiangong", "name": "ye guangfu"}], "number": 12, "message": "success"}
"""
print(d)


d['people']


#
# try it - from a browser or from here...

import requests

url = "https://fvcjsw-5000.csb.app/econ176_mystery0?x=1&y=3"    # perhaps try from browser first!
result_ft = requests.get(url)
# print(result_ft)              # prints the status_code

d = result_ft.json()            # here are the _contents_



#
# a larger api call to the same codesandbox server

import requests

url = "https://fvcjsw-5000.csb.app/fintech"    # try this from your browser first!
result_ft = requests.get(url)
result_ft


#
# let's view ... then parse and interpret!

d = result_ft.json()                  # try .text, as well...
print(f"the resulting data is {d}")


#
# see if you can extract only your initials from d

# we're not finished yet! :)


#
# let's request!   just using the demo, for now:

import requests

url = "https://www.alphavantage.co/query?function=time_series_daily&symbol=msft&apikey=demo"    # demo version
result = requests.get(url)



#
# let's view ... then parse and interpret!

d = result.json()                       # probably _don't_ try .text here!
print(f"the resulting data's keys are {list(d.keys())}")


#
# let's look at all of the keys...

for k in d['time series (daily)']:
    print(k)

# aha! they are dates... let's create a function to compare two dates


#
# here is one way to make a list of all of the dates:

dates = list(d['time series (daily)'].keys())

# notice, they're backwards!


#
# let's flip the dates around:
dates.reverse()

# yay!


# oooh... now let's see what's in each key (date)

d['time series (daily)']['2025-01-21']  # aha! it's a dictionary again!  we will need to index again!!


# a small function to get the closing price on a date (date) using data (dictionary) d
def get_closing(date, d):
    close = float(d['time series (daily)'][date]['4. close'])
    return close


# a loop to find the minimum closing price
#

min_price = 10000000
min_key = "nothing"

for date in d['time series (daily)']:
    closing =  get_closing(date, d)
    # print(f"date is {date} and closing is {closing}")
    if closing < min_price:
        min_price = close
        min_price_date = date

print(f"min_price_date is {min_price_date} and {min_price = }")


# request using my api key mtwvu7gbvgxvxnpb
# microsoft inc. stock analysis
import requests

url = "https://www.alphavantage.co/query?function=time_series_daily&symbol=msft&apikey=mtwvu7gbvgxvxnpb"
result = requests.get(url)



#
# let's view ... then parse and interpret!

d = result.json()
print(f"the resulting data's keys are {list(d.keys())}")


#
# let's look at all of the keys...

for k in d['time series (daily)']:
    print(k)

# aha! they are dates... let's create a function to compare two dates


#
# here is one way to make a list of all of the dates:

dates = list(d['time series (daily)'].keys())

# notice, they're backwards!


#
# let's flip the dates around to start in ascending order:
dates.reverse()

# yay!


# oooh... now let's see what's in each key (date)

d['time series (daily)']['2025-01-21']  # aha! it's a dictionary again!  we will need to index again!!


# a small function to get the closing price on a date (date) using data (dictionary) d
def get_closing(date, d):
    close = float(d['time series (daily)'][date]['4. close'])
    return close


# extract the closing price of the 100 dates extracted.
close_price = []
for date in dates:
    close = get_closing(date, d)
    close_price.append(close)

close_price


# find maximum and minimum closing prices and their respective dates
max_price = max(close_price)
min_price = min(close_price)

max_date = dates[close_price.index(max_price)]
min_date = dates[close_price.index(min_price)]

print(f"*maximum closing price: {max_price} on {max_date}\n*minimum closing price: {min_price} on {min_date}")


# graph of closing prices over time
import matplotlib.pyplot as plt

plt.plot(dates, close_price)
plt.xticks(ticks=dates[::5], rotation=45)  # minimize clustered dates on x-axis
plt.xlabel('date', fontweight='bold')
plt.ylabel('closing price', fontweight='bold')
plt.title('closing price over time', fontweight='bold')
plt.show()


# function for single-share analysis
def single_share_analysis(prices):
    min_price, max_profit, buy_date, sell_date = float('inf'), 0, none, none

    for date, price in enumerate(prices):
        if price < min_price:
            min_price = price
            buy_date  = dates[close_price.index(min_price)]

        if price - min_price > max_profit:
            max_profit = price - min_price
            sell_date = dates[close_price.index(price)]

    return buy_date, sell_date, max_profit



# check single-share analysis:
buy_date, sell_date, max_profit = single_share_analysis(close_price)
print(f'the maximum profit achieved is: {max_profit}; by buying on: {buy_date} and selling on: {sell_date}')



# find buy date and sell date indices
buy_idx = dates.index(buy_date)
sell_idx = dates.index(sell_date)


plt.plot(dates, close_price)
plt.scatter(buy_idx, close_price[buy_idx], color='green', label='buy day', zorder=5)
plt.scatter(sell_idx, close_price[sell_idx], color='red', label='sell day', zorder=5)
plt.xlabel('date', fontweight='bold')
plt.ylabel('closing price', fontweight='bold')
plt.xticks(ticks=dates[::5], rotation=45)  # minimize clustered dates on x-axis
plt.title('closing price over time', fontweight='bold')
plt.legend()
plt.show()


# request using my api key mtwvu7gbvgxvxnpb
# apple inc. stock analysis
import requests

url = "https://www.alphavantage.co/query?function=time_series_daily&symbol=aapl&apikey=mtwvu7gbvgxvxnpb"
result = requests.get(url)



#
# let's view ... then parse and interpret!

d = result.json()
print(f"the resulting data's keys are {list(d.keys())}")


#
# let's look at all of the keys...

for k in d['time series (daily)']:
    print(k)

# aha! they are dates... let's create a function to compare two dates


#
# here is one way to make a list of all of the dates:

dates = list(d['time series (daily)'].keys())

# notice, they're backwards!


#
# let's flip the dates around to start in ascending order:
dates.reverse()

# yay!


# oooh... now let's see what's in each key (date)

d['time series (daily)']['2025-01-21']  # aha! it's a dictionary again!  we will need to index again!!


# a small function to get the closing price on a date (date) using data (dictionary) d
def get_closing(date, d):
    close = float(d['time series (daily)'][date]['4. close'])
    return close


# extract the closing price of the 100 dates extracted.
close_price = []
for date in dates:
    close = get_closing(date, d)
    close_price.append(close)

close_price


# find maximum and minimum closing prices and their respective dates
max_price = max(close_price)
min_price = min(close_price)

max_date = dates[close_price.index(max_price)]
min_date = dates[close_price.index(min_price)]

print(f"*maximum closing price: {max_price} on {max_date}\n*minimum closing price: {min_price} on {min_date}")


# graph of closing prices over time
import matplotlib.pyplot as plt

plt.plot(dates, close_price)
plt.xlabel('date', fontweight='bold')
plt.ylabel('closing price', fontweight='bold')
plt.title('closing price over time', fontweight='bold')
plt.show()


# function for single-share analysis
def single_share_analysis(prices):
    min_price, max_profit, buy_date, sell_date = float('inf'), 0, none, none

    for date, price in enumerate(prices):
        if price < min_price:
            min_price = price
            buy_date  = dates[close_price.index(min_price)]

        if price - min_price > max_profit:
            max_profit = price - min_price
            sell_date = dates[close_price.index(price)]

    return buy_date, sell_date, max_profit



# check single-share analysis:
buy_date, sell_date, max_profit = single_share_analysis(close_price)
print(f'the maximum profit achieved is: {max_profit}; by buying on: {buy_date} and selling on: {sell_date}')



# find buy date and sell date indices
buy_idx = dates.index(buy_date)
sell_idx = dates.index(sell_date)


plt.plot(dates, close_price)
plt.scatter(buy_idx, close_price[buy_idx], color='green', label='buy day', zorder=5)
plt.scatter(sell_idx, close_price[sell_idx], color='red', label='sell day', zorder=5)
plt.xlabel('date', fontweight='bold')
plt.ylabel('closing price', fontweight='bold')
plt.xticks(ticks=dates[::5], rotation=45)  # minimize clustered dates on x-axis
plt.title('closing price over time', fontweight='bold')
plt.legend()
plt.show()


