# -*- coding: utf-8 -*-

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WRX5fxRrYfWMqHQQO_SSpyz0P81UBYHt

# Welcome to Web3!

### Blockchain programming using Ethereum and Web3.py

<font size="-1">motivated by <a href="https://snakecharmers.ethereum.org/a-developers-guide-to-ethereum-pt-1/">A Developer's Guide to Ethereum</a> by M. Garreau</font>
"""

# This will update Colab's libraries
#      and will avoid several DeprecationWarnings in the future...

import warnings
warnings.filterwarnings("ignore", category=ImportWarning, append=True)
warnings.filterwarnings("ignore", category=DeprecationWarning, append=True)

# these may need to be repeated, and the append parameter seems suspiciously unintuitive (i.e., not-working)
# this may not be needed
# # install --upgrade ipykernel

# install web3

# install "web3[tester]"

"""#### Let's check that the libraries are working...


"""

from web3 import Web3

"""#### Use auto-completion

It's great to quickly review the data and functions in an object...

Add a period at the end of the <tt>Web3</tt> object to see and review its fields:
"""

# Check out whats available in the Web3 object, by
#       typing a period . after Web3 below
#       (make it Web3.  ~ then wait a moment...)

# Here, add a period (the selector operator) and wait a moment
#       a panel should popup to show all of the available fields

# Check out whats available in the Web3 object, by
#       typing a period . after Web3 below
#       (make it Web3.  ~ then wait a moment...)

# Here, add a period (the selector operator) and wait a moment
#       a panel should popup to show all of the available fields

# Check out from_wei and to_wei !

Web3

"""#### Notice <tt>to_wei</tt> and <tt>from_wei</tt>

... and many others!

Here, let's use <tt>to_wei</tt> from the <tt>Web3</tt> object to convert among different units of Ether:
"""

from web3 import Web3

value_in_wei = Web3.to_wei(1, 'ether')
print(f"1 eth is {value_in_wei} wei.")

"""Here are names for the "coins" of the Ether realm:

<img src="https://m.foolcdn.com/media/dubs/images/gwei-infographic.width-880.png" height="284px">

The nicknames are a mix of computing and cryptography/Ethereum early-explorers...   ðŸ˜€

#### Let's try out the <tt>gwei</tt> unit

Gwei are the typical units for Ethereum's <i>gas</i>

This also shows off the use of <tt>from_wei</tt>

<font size="-1"><i>Warning</i> &nbsp; We will use <i>floating-point</i> for readability. For exact artihmetic, everything must be in integers (and probably in <tt>wei</tt>).</font>
"""

# converting to other units...
#            with the function Web3.from_wei

value_in_gwei = float(Web3.from_wei(42_000_000_000, 'gwei'))
value_in_gwei

# Python allows underscores instead of commas:
# gwei is short for "gigawei" which is 1 billion wei
# Note that, in Python, the underscore is a legal "thousands-separator"  (cool!)

"""## <b><font color="DodgerBlue">Challenge #1</font></b> &nbsp;&nbsp; <i>Current</i> currency conversion

<b><font color="Coral">Task</font></b> &nbsp;&nbsp;  Write a function that finds the value, in dollars, of 1 ether and finds the value, in ether and gwei, of 1 dollar. Use the <i>current</i> value of the currencies!

For example, here is how the function might look when it's run:

```
# the call to your function:
your_function()   # choose your own name

# the output, printed:
1 ether is currently  $1342.26

1 dollar is currently .000745012143697942 ether
1 dollar is about     745012.14 gwei
```

#### Remember <tt>requests</tt> ?

<tt>requests</tt> was the Python library our API module used to make API requests to arbitrary endpoints (urls). This is a great way to help implement this function  et's get the current price of ETH...
And use that to convert from dollars to gwei and gwei to dollars...

<br>

#### <i>Use the AI to build-in current ETH pricing...</i>

+ Prompt Colab to use requests API to get the current price of ETH
+ Test the code version(s) it provides to find one that works (and that you like)
+ Continue on, to create your function above...
+ Use better names! For example,  <tt>dollars_to_gwei</tt> or <tt>gwei_to_dollars</tt> would be reasonable helper functions
+ (No requirement for a helper function in this case.)

#### Show that it is working as desired!
+ Run it!
+ <b>Confirm</b> that they are correct by checking the "opposite" results in another cell...
"""

# prompt: use requests api to get the current price of eth

import requests

def get_eth_price():
    try:
        url = 'https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd'
        response = requests.get(url)
        response.raise_for_status()  # Raise an exception for bad status codes
        data = response.json()
        eth_price = data['ethereum']['usd']
        return eth_price
    except requests.exceptions.RequestException as e:
        print(f"Error fetching ETH price: {e}")
        return None

def eth_price_info():
    eth_price = get_eth_price()
    if eth_price:
        print(f"1 ether is currently ${eth_price:.2f}")
        print(f"1 dollar is currently {1/eth_price:.15f} ether")
        print(f"1 dollar is about {1/eth_price * 1e9:.2f} gwei")

eth_price_info()

def dollarsToGwei(amount):
    eth_price = get_eth_price()
    if eth_price:
        return amount * 1e9 / eth_price


def gweiToDollars(amount):
    eth_price = get_eth_price()
    if eth_price:
        return amount * eth_price / 1e9
print("---------------")
print("calling my function:")
print(f"1 ether is currently ${dollarsToGwei(1):.2f}")
print(f"1 dollar is about {gweiToDollars(1) * 1e9:.2f} gwei")

#
# Feel free to create your own cells for this challenge...
#

"""## <b><font color="DodgerBlue">Challenge #2</font></b> &nbsp;&nbsp; <i>Reflect</i> on the AI code success ...

<b><font color="Coral">Task</font></b> &nbsp;&nbsp;  In developing the above current-currency-conversion function,
+ was the AI able to create the API call you needed?
+ did it format the result as you'd hoped?
+ were there things you had to add to the output code?
+ and - bigger-picture - have you found the Colab AI more helpful as time goes on (or less so?!)

<br>
<hr>
<br>

<font size="-1">Things working too smoothly? <br> Tired of typing/generating the same-old prose answers? <br> Liven up your Colab up with some <font color="DodgerBlue">raw html</font>! <br> Copy the following into a _code_ cell:
```
%%html
<marquee style='width: 30%; color: Coral;'><b>It Works!</b></marquee>
```
</font>
"""

print("Yes, the AI created the API call that I needed, although maybe not in the right format. I had to add some formatting to the printed portion but besides that, colab AI did a greta job itself. I havem't used colab AI that much, but as time goes on I continue to be impressed!")

"""<font color="Coral"><b>task</b></font>

#### Be sure to include at least one cell - of whatever sort - for your AI-success reflection...

<font color="lightgray" size="-2">
Look below for a "cookie clicker" application inside Colab! :)
<font>

<!-- Cookie Clicker (generalized snack version):  
     Copy the code below into a code cell:  


%%html
<head>
  <style>
    button {
      font-size: 2rem;        /*  1 rem is 16 pixels and 12 point */
      padding: 10px 20px;     /*  x padding and y padding         */
    }
  </style>
</head>
<body>
  <button id="snack" onclick="increment()">0</button>
  <script>
    let delta = 1;
    function increment() {
      const btn = document.getElementById('snack');        // our "snack" clicker!
      let count = parseInt(btn.innerText);                 // get the button number
      if (count >= 4.2 || count <= -4.2) { delta *= -1; }  // switch the direction
      btn.innerText = count + delta;                       // update with the current delta
    }
  </script>
</body>
</html>


-->

## Ok!  Let's connect to "the" Ethereum blockchain

+ We will be using the <tt>Web3.py</tt> <i>TesterProvider</i>
+ This is an Ethereum "sandbox" so that we won't have to stake any actual funds
+ Plus, the sandbox blockchain will give us <i>lots</i> of ether!  ðŸ˜ƒ
"""

#
# Here, we create a blockchain-connected Web3 object
#       Web3.EthereumTesterProvider() is our sandbox "provider"
#
# You WILL see some ImportWarnings...   (ignore those; they're Colab, not Ethereum or Web3)

provider = Web3.EthereumTesterProvider()
w3 = Web3(provider)
print("w3 is", w3)

"""#### Are we connected?"""

w3.is_connected()

# Try using the completion panel and <tab> to find w3.eth.accounts ...

w3

# These are the public addresses of the accounts we have

w3.eth.accounts

# how many accounts do we have?
len(w3.eth.accounts)

"""#### Nice!

Let's see how much is in one of the accounts, say the one at index 3:
"""

current_account = w3.eth.accounts[3]  # let's use #3

balance_in_wei = w3.eth.get_balance(current_account)

print(f"There are {balance_in_wei} wei in account #3.")

"""Let's see how big this is as a power of 10. &nbsp;&nbsp; (in floating point)"""

#
# Let's see it in floating point...

w = float(balance_in_wei)

print(f"There are a total of {w = } wei (in floating point), with 10**18 wei per ETH")

"""## <b><font color="DodgerBlue">Challenge #3</font></b> &nbsp;&nbsp; Count your gold! &nbsp; (or ether...)

<b><font color="Coral">Task</font></b> &nbsp;&nbsp;  Use your code from earlier in this notebook -- and any AI help you might want -- to create a new function (you choose the name) that
+ finds the amount of Ether in ***all*** of your accounts
+ adds it all up
+ converts it to dollars
+ prints out the total dollars you have ...
+ and <tt>returns</tt> that value back from the function

<br><br>
"""

#
#  a small example of how to print all account balances
#          feel free to adapt or remove

#  this doesn't quite address the above challenge, but it's a start!

index = 0
for account in w3.eth.accounts:
    balance_in_wei = w3.eth.get_balance(account)
    balance_in_ETH = Web3.from_wei(balance_in_wei, 'ether')
    print(f"Account #{index}  amount: {balance_in_ETH}")
    index += 1

def countDollars(accounts):
    sum = 0
    for account in accounts:
        balance_in_wei = w3.eth.get_balance(account)
        balance_in_ETH = Web3.from_wei(balance_in_wei, 'ether')
        sum += balance_in_wei
    return gweiToDollars(sum)/1000000000

print(countDollars(w3.eth.accounts))



"""## Let's transact!

First, let's see the latest block in our blockchain...

Then, let's create a single transaction and track its effects...

Then, we'll run a whole marketplace's-worth of transactions!
"""

# sometimes this helps...
import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)

#
# Let's see the latest block in our blockchain:

b = w3.eth.get_block('latest')   # this will be the "genesis" block
b

# Notice the number!

# Let's check the block's number, specifically
# Note that b is a dictionary:

print("Block b's number is ", b['number'])

"""#### Now, let's try our single, one-time transaction

<i>Warning</i>: &nbsp;&nbsp; If you run this more than once, it will transact more than once!

<font size="-1">This is not really a warning, actually. Try it! ðŸ˜€</font>
"""

# sometimes this helps with the warnings we don't want:
warnings.filterwarnings("ignore", category=ImportWarning)

#
# Let's create a single transaction:
#       Notice that the transaction is a dictionary
#       It's created, sent to the chain, and a hash is returned:

transaction = {                          # the transaction is a dictionary!
    'from': w3.eth.accounts[3],          # from acct 3
    'to': w3.eth.accounts[8],            # to acct 8
    'value': w3.to_wei(42000, 'ether')   # amount is 42,000 ether!
}

# now, we send the transaction to the blockchain:
tx_hash = w3.eth.send_transaction(transaction)

# let's look at its resulting hash
print("Done!\n")
print(f"The transaction hash is ... {tx_hash = }")

#
# getting the transaction is possible through that transaction hash

# It will return a dictionary of values:
d = w3.eth.get_transaction(tx_hash)
d

#
# let's get the block number from within those transaction details...

block_number = d['blockNumber']
print(f"{block_number = }")

#
# Then, let's get that block, from the blocknumber!

b = w3.eth.get_block(block_number)
b

#
# Which should be the same as getting the latest block:

b = w3.eth.get_block('latest')
b

"""### Let's see the <font color="DodgerBlue"><b>current amount</b></font> in each of the accounts:"""

#
#  a small example of how to print all account balances
#                  feel free to adapt or remove!

index = 0
for account in w3.eth.accounts:
    balance_in_wei = w3.eth.get_balance(account)
    balance_in_ETH = Web3.from_wei(balance_in_wei, 'ether')
    print(f"Account #{index}  amount: {balance_in_ETH} ether")
    index += 1


# create total, function, return, ...

"""### What if we don't have enough currency for the requested transaction?

If a transaction is requested for too-large an amount, the request fails and it is rolled back.

Let's try it:
"""

#
# Let's create a single transaction for TOO MUCH ether
#       Notice that the transaction is a dictionary
#       It's created, sent to the chain, and a hash is returned:

transaction = {                          # the transaction is a dictionary!
    'from': w3.eth.accounts[3],          # from acct 3
    'to': w3.eth.accounts[8],            # to acct 8
    'value': w3.to_wei(42_000_000, 'ether')   # amount is 42 _million_ ether!
}

# now, we send the transaction to the blockchain:
tx_hash = w3.eth.send_transaction(transaction)

# let's look at its resulting hash
print("Done!\n")
tx_hash

"""### A `ValidationError` results!

The transaction does ***not*** succeed.

Any transaction should use `try ... except ...` error-handling blocks in order to catch these potential errors.

Let's see how this will work:
"""

#
# Let's create a single transaction for TOO MUCH ether
#       Notice that the transaction is a dictionary
#       It's created, sent to the chain, and a hash is returned:

from eth_utils import ValidationError

transaction = {                           # the transaction is a dictionary!
    'from': w3.eth.accounts[3],           # from acct 3
    'to': w3.eth.accounts[8],             # to acct 8
    'value': w3.to_wei(42_000, 'ether')   # change this to/from 42 _million_ ether!
}

# now, we send the transaction to the blockchain -- with a TRY/EXCEPT error-handler"
try:
    tx_hash = w3.eth.send_transaction(transaction)
    # let's look at its resulting hash
    print("Success!\n")
    print(f"The {tx_hash = }")
except ValidationError as e:
    print("Transaction failed: Insufficient funds.   This time we've _caught_ this exception. [[ Everything is fine... Nothing to see here... ]] \n")
    print(f"Here is the full ValidationError:\n    {e}")

"""## <b><font color="DodgerBlue">Challenge #4</font></b> &nbsp;&nbsp; A bustling  marketplace...

<b><font color="Coral">Task</font></b> &nbsp;&nbsp;  Use the example, above,  -- and any AI help you might want -- to create functions and cells that
+ run <tt>N</tt> transactions, perhaps once every 2-3 seconds
+ print what's running , e.g., "Account 3 is sending 42,042 ether to Account 8"
+ uses random amounts (you choose the span that's ok)
+ uses random accounts (you choose how to handle this randomness)

<br><br>

<b><font color="Coral">Task 2</font></b> &nbsp;&nbsp;  Run your marketplace a small number of times, e.g., 10 transactions, and print the slate of account values at the end, <i>including the total across all of the accounts</i>.
+ How much gas has been used, across all of the accounts?
+ What are the <i>variance</i> and <i>inequality</i> (as measured by the <i>gini coefficient</i>) across all of the accounts?

<br><br>

<b><font color="Coral">Task 3</font></b> &nbsp;&nbsp;  Run the same marketplace, but now for ***lots*** of transactions. Again, include the resulting account balances, the amount of gas used (total), and the measure of inequality -- which should be the <i>gini inequality</i> or <i>gini coefficient</i>  -- of the result. <br> <font size="-2">How to implement  Gini inequality? Feel free to use AI or [Wikipedia](https://en.wikipedia.org/wiki/Gini_coefficient), which is probably what the AI will have used!</font>

This time, add one more capability to your marketplace:
+ when an account tries to overspend, it spends all it has and then stops spending (it doesn't crash!)
+ one way to do this is to keep a list of the <i>insolvent</i> accounts, starting with the empty list `[ ]`
+ Then, when an account tries to overspend, the transaction will be denied, but it would then go onto the insolvent list -- and will be ignored from then on.
+ equivalently, you could start with a list of <i>solvent</i> accounts and then remove accounts from it when they first try to overspend...

<br><br>

<b><font color="Coral"><u>Finale</u>: &nbsp; The Tontine</font></b> &nbsp;&nbsp;  Run the same marketplace, but now until there is only one account with positive balance...  This time, the questions are slightly different:
+ how many "generations" did it take until one account
+ for each generation, measure and remember the inequality-measure across all 10 accounts (for example, into a list)
+ ***create a plot*** of the balances from the start until the Tontine is won.
+ also, ***create a plot of the Gini inequality/coefficient*** across that time...

You should adapt <i>how much</i> the accounts decide to exchange, so that this is both interesting and not too slow.

<br>

<b><font color="DodgerBlue"><u>Reflection</u></font></b>: &nbsp; **Share your thoughts** on how this programming-and-simulation challenge went -- if you used AI, share how useful (or not) that was. This can be in a new text cell or in comments accompanying your executable cells...

<br><br>
<br><br>

<hr>
<br>

<b><font color="Coral">Hint</font></b> &nbsp;&nbsp; Here is an example of the final cell used for the in-class example. Notice that
+ the function `run_transactions()` does all of the work
+ the two lines above simply "reset" all 10 ETH accounts to 1,000,000 ETH each (wow!)
+ the function `run_transactions()` returns two lists:
  + the list `GiniCoefficients` holds all of those gini coefficients for the whole tontine
  + the line `AllBalances` holds ALL of the balances of all of the accounts for the whole tontine
+ these two were used in order to plot the inequality values and balances...
"""

# Example of resetting the universe and running the results:
provider = Web3.EthereumTesterProvider()
w3 = Web3(provider)

GiniCoefficients, AllBalances = run_transactions()

#Task #1

# prompt: run a few transactions using random accounts and random amounts

import random
import time
import warnings

def run_transactions(num_transactions=10):
    insolvent_accounts = []
    all_balances = []

    for _ in range(num_transactions):
        sender_index = random.randint(0, len(w3.eth.accounts) - 1)
        recipient_index = random.randint(0, len(w3.eth.accounts) - 1)

        while sender_index == recipient_index:
            recipient_index = random.randint(0, len(w3.eth.accounts) - 1)

        sender = w3.eth.accounts[sender_index]
        recipient = w3.eth.accounts[recipient_index]

        if sender in insolvent_accounts:
            continue

        amount = random.randint(1, 1000)  # Adjust the range as needed

        transaction = {
            'from': sender,
            'to': recipient,
            'value': w3.to_wei(amount, 'ether')
        }

        try:
            tx_hash = w3.eth.send_transaction(transaction)
            print(f"Account {sender_index} sent {amount} ETH to Account {recipient_index}")
            time.sleep(random.uniform(1, 3))  # Random delay

        except ValidationError as e:
            print(f"Transaction failed: {e}")
            insolvent_accounts.append(sender)

        balances = []
        for account in w3.eth.accounts:
            balance = w3.eth.get_balance(account)
            balances.append(balance)
        all_balances.append(balances)

    total_balance = sum(balances)
    print("\nFinal Balances:")
    for i, balance in enumerate(balances):
        print(f"Account {i}: {Web3.from_wei(balance, 'ether')} ETH")

    print(f"\nTotal Balance: {Web3.from_wei(total_balance, 'ether')} ETH")
    return all_balances


# Example usage
run_transactions()

# Task 2

from eth_utils import ValidationError

transaction1 = {                           # the transaction is a dictionary!
    'from': w3.eth.accounts[1],           # from acct 3
    'to': w3.eth.accounts[0],             # to acct 8
    'value': w3.to_wei(42_000, 'ether')   # change this to/from 42 _million_ ether!
}
transaction2 = {                           # the transaction is a dictionary!
    'from': w3.eth.accounts[2],           # from acct 3
    'to': w3.eth.accounts[9],             # to acct 8
    'value': w3.to_wei(42_000, 'ether')   # change this to/from 42 _million_ ether!
}
transaction3 = {                           # the transaction is a dictionary!
    'from': w3.eth.accounts[3],           # from acct 3
    'to': w3.eth.accounts[8],             # to acct 8
    'value': w3.to_wei(42_000, 'ether')   # change this to/from 42 _million_ ether!
}
transaction4 = {                           # the transaction is a dictionary!
    'from': w3.eth.accounts[4],           # from acct 3
    'to': w3.eth.accounts[7],             # to acct 8
    'value': w3.to_wei(42_000, 'ether')   # change this to/from 42 _million_ ether!
}
transaction5 = {                           # the transaction is a dictionary!
    'from': w3.eth.accounts[5],           # from acct 3
    'to': w3.eth.accounts[6],             # to acct 8
    'value': w3.to_wei(42_000, 'ether')   # change this to/from 42 _million_ ether!
}
transaction6 = {                           # the transaction is a dictionary!
    'from': w3.eth.accounts[0],           # from acct 3
    'to': w3.eth.accounts[9],             # to acct 8
    'value': w3.to_wei(42_000, 'ether')   # change this to/from 42 _million_ ether!
}
transaction7 = {                           # the transaction is a dictionary!
    'from': w3.eth.accounts[8],           # from acct 3
    'to': w3.eth.accounts[7],             # to acct 8
    'value': w3.to_wei(42_000, 'ether')   # change this to/from 42 _million_ ether!
}
transaction8 = {                           # the transaction is a dictionary!
    'from': w3.eth.accounts[6],           # from acct 3
    'to': w3.eth.accounts[5],             # to acct 8
    'value': w3.to_wei(42_000, 'ether')   # change this to/from 42 _million_ ether!
}
transaction9 = {                           # the transaction is a dictionary!
    'from': w3.eth.accounts[4],           # from acct 3
    'to': w3.eth.accounts[3],             # to acct 8
    'value': w3.to_wei(42_000, 'ether')   # change this to/from 42 _million_ ether!
}
transaction10 = {                           # the transaction is a dictionary!
    'from': w3.eth.accounts[2],           # from acct 3
    'to': w3.eth.accounts[1],             # to acct 8
    'value': w3.to_wei(42_000, 'ether')   # change this to/from 42 _million_ ether!
}

# now, we send the transaction to the blockchain -- with a TRY/EXCEPT error-handler"
try:
    tx_hash = w3.eth.send_transaction(transaction1)
    tx_hash = w3.eth.send_transaction(transaction2)
    tx_hash = w3.eth.send_transaction(transaction3)
    tx_hash = w3.eth.send_transaction(transaction4)
    tx_hash = w3.eth.send_transaction(transaction5)
    tx_hash = w3.eth.send_transaction(transaction6)
    tx_hash = w3.eth.send_transaction(transaction7)
    tx_hash = w3.eth.send_transaction(transaction8)
    tx_hash = w3.eth.send_transaction(transaction9)
    tx_hash = w3.eth.send_transaction(transaction10)
    # let's look at its resulting hash
    print("Success!\n")
    print(f"The {tx_hash = }")
except ValidationError as e:
    print("Transaction failed: Insufficient funds.   This time we've _caught_ this exception. [[ Everything is fine... Nothing to see here... ]] \n")
    print(f"Here is the full ValidationError:\n    {e}")

index = 0
for account in w3.eth.accounts:
    balance_in_wei = w3.eth.get_balance(account)
    balance_in_ETH = Web3.from_wei(balance_in_wei, 'ether')
    print(f"Account #{index}  amount: {balance_in_ETH} ether")
    index += 1

tx_hash1 = w3.eth.send_transaction(transaction1)
tx_hash2 = w3.eth.send_transaction(transaction2)
tx_hash3 = w3.eth.send_transaction(transaction3)
tx_hash4 = w3.eth.send_transaction(transaction4)
tx_hash5 = w3.eth.send_transaction(transaction5)
tx_hash6 = w3.eth.send_transaction(transaction6)
tx_hash7 = w3.eth.send_transaction(transaction7)
tx_hash8 = w3.eth.send_transaction(transaction8)
tx_hash9 = w3.eth.send_transaction(transaction9)
tx_hash10 = w3.eth.send_transaction(transaction10)

sum = 0
sum += w3.eth.get_transaction(tx_hash1)['gas']
sum += w3.eth.get_transaction(tx_hash2)['gas']
sum += w3.eth.get_transaction(tx_hash3)['gas']
sum += w3.eth.get_transaction(tx_hash4)['gas']
sum += w3.eth.get_transaction(tx_hash5)['gas']
sum += w3.eth.get_transaction(tx_hash6)['gas']
sum += w3.eth.get_transaction(tx_hash7)['gas']
sum += w3.eth.get_transaction(tx_hash8)['gas']
sum += w3.eth.get_transaction(tx_hash9)['gas']
sum += w3.eth.get_transaction(tx_hash10)['gas']
print("----------------")
print(f"Total gas used = {sum}")

#task 3 - used AI for this since the directions for this one said feel free to use AI
import numpy as np
def gini_coefficient(balances):
    """Calculate the Gini coefficient from a list of balances."""

    array = np.array([float(b) for b in balances])
    if np.amin(array) < 0:
        array -= np.amin(array)
    array += 0.0000001  # prevent division by zero
    array = np.sort(array)
    index = np.arange(1, array.shape[0]+1)
    n = array.shape[0]
    return ((np.sum((2 * index - n - 1) * array)) / (n * np.sum(array)))

def run_transactions(num_transactions):
    insolvent_accounts = set()
    all_accounts = w3.eth.accounts
    total_gas_used = 0

    GiniCoefficients = []
    AllBalances = []

    for i in range(num_transactions):
        sender_index = random.randint(0, len(all_accounts) - 1)
        recipient_index = random.randint(0, len(all_accounts) - 1)
        while recipient_index == sender_index:
            recipient_index = random.randint(0, len(all_accounts) - 1)

        sender = all_accounts[sender_index]
        recipient = all_accounts[recipient_index]

        if sender in insolvent_accounts:
            continue

        amount = random.randint(1, 1000)
        sender_balance = w3.eth.get_balance(sender)
        value_in_wei = w3.to_wei(amount, 'ether')

        if sender_balance < value_in_wei:
            if sender_balance == 0:
                insolvent_accounts.add(sender)
                continue
            else:
                print(f"Account {sender_index} tried to overspend. Sending remaining {Web3.from_wei(sender_balance, 'ether')} ETH and marking insolvent.")
                value_in_wei = sender_balance
                insolvent_accounts.add(sender)

        transaction = {
            'from': sender,
            'to': recipient,
            'value': value_in_wei
        }

        try:
            tx_hash = w3.eth.send_transaction(transaction)
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
            gas_used = tx_receipt['gasUsed']
            total_gas_used += gas_used

            print(f"Transaction {i+1}: Account {sender_index} sent {Web3.from_wei(value_in_wei, 'ether')} ETH to Account {recipient_index} (Gas used: {gas_used})")

            balances = [Web3.from_wei(w3.eth.get_balance(account), 'ether') for account in all_accounts]
            AllBalances.append(balances)

            gini = gini_coefficient(balances)
            GiniCoefficients.append(gini)

            time.sleep(random.uniform(0.5, 1.5))

        except Exception as e:
            print(f"Transaction {i+1} failed: {e}")
            insolvent_accounts.add(sender)

    print("\nFinal Total Gas Used:", total_gas_used)
    return GiniCoefficients, AllBalances


GiniCoefficients, AllBalances = run_transactions(100)

def run_tontine():
    accounts = w3.eth.accounts

    reset_balances(accounts)

    GiniCoefficients = []
    AllBalances = []
    generations = 0

    while True:
        balances_wei = [w3.eth.get_balance(acct) for acct in accounts]
        positive_indices = [i for i, bal in enumerate(balances_wei) if bal > 0]

        if len(positive_indices) <= 1:
            break

        sender_idx = random.choice(positive_indices)
        recipient_idx = random.choice([i for i in range(len(accounts)) if i != sender_idx])

        sender = accounts[sender_idx]
        recipient = accounts[recipient_idx]

        sender_balance = balances_wei[sender_idx]

        # Gas safety
        gas_limit = 21_000  # simple transfer
        gas_price = w3.eth.gas_price
        gas_fee = gas_limit * gas_price

        # Can we send at least 1 ETH?
        one_eth = w3.to_wei(1, 'ether')
        if sender_balance > (one_eth + gas_fee):
            value = one_eth
        else:
            # Send whatever is left minus gas
            max_value = sender_balance - gas_fee
            if max_value <= 0:
                continue  # skip if we can't cover gas + anything to send
            value = max_value  # send all except gas

        tx = {'from': sender, 'to': recipient, 'value': value}
        try:
            w3.eth.send_transaction(tx)
        except:
            continue

        # Track stats
        gen_balances = [float(Web3.from_wei(w3.eth.get_balance(a), 'ether')) for a in accounts]
        AllBalances.append(gen_balances)
        GiniCoefficients.append(gini_coefficient(gen_balances))
        generations += 1

        if generations % 10 == 0:
            print(f"Generation {generations}: {len(positive_indices)} accounts with positive balance.")

    print(f"Tontine complete after {generations} generations!")
    return generations, GiniCoefficients, AllBalances

import matplotlib.pyplot as plt
import numpy as np

# Convert AllBalances to a NumPy array for easy plotting
AllBalances = np.array(AllBalances)

# Plot 1: Account Balances Over Time
plt.figure(figsize=(12, 6))
for i in range(AllBalances.shape[1]):
    plt.plot(AllBalances[:, i], label=f'Account {i}')
plt.title('Account Balances Over Generations (Tontine)')
plt.xlabel('Generation')
plt.ylabel('ETH Balance')
plt.legend(loc='upper right')
plt.grid(True)
plt.show()

# Plot 2: Gini Coefficient Over Time
plt.figure(figsize=(10, 5))
plt.plot(GiniCoefficients, color='red')
plt.title('Gini Coefficient Over Generations (Tontine)')
plt.xlabel('Generation')
plt.ylabel('Gini Coefficient')
plt.grid(True)
plt.show()

#Reflection: I enjoyed this problem set a lot. Seeing the random transfers in part 2 go through with everything I have learned about eth up until this point was exciting. I learned about gas and the gini coefficient, both of which were new concepts for me. I ended up using AI for parts 3 and 4, which ended up being extremely helpful.
