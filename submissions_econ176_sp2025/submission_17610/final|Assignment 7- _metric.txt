# some of the libraries have warnings we want to ignore...
import warnings
warnings.filterwarnings("ignore")

# ai/ml libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.datasets import fetch_openml




# fetch the insurance-claim dataset from the openml repository  (an api call! :)
all = fetch_openml(data_id=45106, as_frame=true)


# extract the pieces of the api result from the openml api call
df_all = all.data
df_all["claim_nb"] = all.target

print("shape of full data:", df_all.shape)
df_all.head(15)    # print the first five rows of data


df_all.describe()


#
# it's easiest to make additional code cells...
#


# histogram of drivers' ages
plt.figure(figsize=(10, 6))
plt.hist(df_all['driver_age'], bins=30, alpha=0.7, color='blue', edgecolor='black')
plt.title('distribution of driver ages', fontsize=14)
plt.xlabel('driver age (years)', fontsize=12)
plt.ylabel('frequency', fontsize=12)
plt.grid(alpha=0.3)
plt.show()

# histogram of cars' ages
plt.figure(figsize=(10, 6))
plt.hist(df_all['car_age'], bins=25, alpha=0.7, color='green', edgecolor='black')
plt.title('distribution of car ages', fontsize=14)
plt.xlabel('car age (years)', fontsize=12)
plt.ylabel('frequency', fontsize=12)
plt.grid(alpha=0.3)
plt.show()


# histogram of claim numbers
plt.figure(figsize=(10, 6))
plt.hist(df_all['claim_nb'], bins=np.arange(-0.5, 5.5, 1), alpha=0.7, color='red', edgecolor='black')
plt.title('distribution of insurance claims', fontsize=14)
plt.xlabel('number of claims', fontsize=12)
plt.ylabel('frequency', fontsize=12)
plt.xticks(range(0, 5))
plt.grid(alpha=0.3)
plt.show()

# scatter plot of car age vs driver age
plt.figure(figsize=(10, 6))
# take a random sample to avoid overplotting
sample_size = 50000
sample_df = df_all.sample(sample_size, random_state=42)
plt.scatter(sample_df['driver_age'], sample_df['car_age'], alpha=0.3, s=10)
plt.title('car age vs driver age', fontsize=14)
plt.xlabel('driver age (years)', fontsize=12)
plt.ylabel('car age (years)', fontsize=12)
plt.grid(alpha=0.3)
plt.show()


# scatter plot of claim_nb vs driver age
plt.figure(figsize=(10, 6))
# use jittering to better visualize discrete claim values
claims_df = df_all.sample(sample_size, random_state=24)
plt.scatter(claims_df['driver_age'], claims_df['claim_nb'] + np.random.normal(0, 0.05, len(claims_df)), 
            alpha=0.3, s=10, color='purple')
plt.title('number of claims vs driver age', fontsize=14)
plt.xlabel('driver age (years)', fontsize=12)
plt.ylabel('number of claims', fontsize=12)
plt.grid(alpha=0.3)
plt.show()

# additional scatter plot: car_power vs claim_nb with town as color
plt.figure(figsize=(10, 6))
power_claims_df = df_all.sample(sample_size, random_state=35)
scatter = plt.scatter(power_claims_df['car_power'], 
                     power_claims_df['claim_nb'] + np.random.normal(0, 0.05, len(power_claims_df)),
                     c=power_claims_df['town'], cmap='viridis', 
                     alpha=0.5, s=15)
plt.colorbar(scatter, label='town (1=urban, 0=rural)')
plt.title('number of claims vs car power (colored by town)', fontsize=14)
plt.xlabel('car power (hp)', fontsize=12)
plt.ylabel('number of claims', fontsize=12)
plt.grid(alpha=0.3)
plt.show()


# let's make sure everything runs first... using only 100,000 rows (instead of 1,000,000)

df_all = df_all.sample(frac=1.0, random_state=42)  # this shuffles the 1,000,000-row dataset

numrows = 100000
df = df_all.iloc[0:numrows,:].copy()    # this uses only the first 100,000 rows (or numrows rows) for speed...


# we split into 90% training data and 10% testing data

from sklearn.model_selection import train_test_split

train, test = train_test_split(df, test_size=0.1, random_state=30)
print("shape of training data:", train.shape)
print("shape of test data:", test.shape)


# define target name (y) and feature names (x)
y, x = df.columns[-1], list(df.columns[:-1])

print("the response name:", y)
print("the feature names:", x)





#
# there's not much code to build our model!
#
from glum import generalizedlinearregressor

glm_model = generalizedlinearregressor(family="poisson", alpha=1e-6)
glm_model.fit(x=train[x], y=train[y])

print("coefficients")
pd.series(np.append(glm_model.intercept_, glm_model.coef_), index=["intercept"] + x)


from math import exp
exp(0.36)


exp(0.360105)    # for each unit of "townness,"  we multiply the expected claims by 1.433:


exp(0.360105) ** 2   # so, we multiply twice for _two_ units of "townness":


exp(-0.003272)    # for each year of driver_age, you multiply the expected claims by 0.9967:


0.9967 ** 15


exp(-0.003272)**(88-18)


1/0.7952


from math import exp

print("car power analysis:")
print(f"per unit multiplier: {exp(0.004117)}")
print(f"50hp increase: {exp(0.004117 * 50)}")
print(f"full range (50hp to 341hp): {exp(0.004117 * (341-50))}")

print("car weight analysis:")
print(f"per unit (kg) multiplier: {exp(-0.000068)}")
print(f"500kg increase: {exp(-0.000068 * 500)}")
print(f"full range (950kg to 3120kg): {exp(-0.000068 * (3120-950))}")


import shap


import shap

# first, extract background data. this is the same for all models to interpret:
x_bg = train[x].sample(200, random_state=8366)    # grab 200 samples from our training data - 200 is a lot...

# exploring the space...   this will take a while...
glm_explainer = shap.kernelexplainer(lambda x: np.log(glm_model.predict(x)), data=x_bg)     # don't worry about the warnings!

# then, we can choose any data to explain. we'll choose 1,000 rows randomly called x_explain
x_explain = train[x].sample(n=1000, random_state=937)
shap_glm = glm_explainer.shap_values(x_explain, nsamples=30) # there are 30 non-trivial subsets of 6 features


x_explain[0:1]


shap_glm[0:1]


#
# a function to create all of the dependence plots among our features
#
def all_dep_plots(x, shap_values, x):
    """ dependence plots for all features x. """
    fig, _ = plt.subplots(nrows=2, ncols=3, figsize=(10, 6), sharey=true)

    for i, ax in enumerate(fig.axes):
        xvar = x[i]
        shap.dependence_plot(
            xvar,
            shap_values,
            features=x,
            x_jitter=0.2 * (xvar in ("town", "year")),
            ymin=-0.5,
            ymax=1,
            ax=ax,
            show=false,
        )
        ax.set_title(xvar, fontdict={"size": 16})
        ax.set_ylabel("shap values" if i % 3 == 0 else "")
        ax.grid()
    plt.tight_layout()

print("the all_dep_plots function has been defined.")
print("run the next cell to plot the features and their impacts")


all_dep_plots(x, shap_glm, x_explain)


# scale features to [-1, 1]
from sklearn.preprocessing import minmaxscaler

nn_preprocessor = minmaxscaler(feature_range=(-1, 1))
x_train = nn_preprocessor.fit_transform(train[x])

print("output after the data has been scaled:")
pd.dataframe(x_train[0:5], columns=x)


#
# neural nets are worthy of their own course, for sure...
#
import tensorflow as tf
from tensorflow import keras
from keras import layers
from keras.callbacks import earlystopping, reducelronplateau
from keras.optimizers import adam
cb = [earlystopping(patience=20), reducelronplateau(patience=5)]  # "callbacks" for training (see below)

# architecture
inputs = keras.input(shape=(len(x),))
# additional layers can be added here!
outputs = layers.dense(1, activation="exponential")(inputs)
nn_model_shallow = keras.model(inputs=inputs, outputs=outputs)

nn_model_shallow.summary()

# calculate gradients
nn_model_shallow.compile(optimizer=adam(learning_rate=1e-4), loss="poisson")


#
# train the network!
#

tf.random.set_seed(4349)

history_shallow = nn_model_shallow.fit(
    x=x_train,
    y=train[y],
    epochs=200,
    batch_size=10_000,
    validation_split=0.1,
    callbacks=cb,
    verbose=1,         # consider running both values 0 (no printing) and 1 (printing)
)


# prompt: could you show a heatmap of the values of the neuron's weights in the above model, named nn_model?

import seaborn as sns
import matplotlib.pyplot as plt

# here, nn_model_shallow is the keras (nnet) model
weights = nn_model_shallow.layers[1].get_weights()[0]  # get weights from this layer (omitting the intercepts, which are in [1])
weights = np.transpose(weights)

# create a heatmap of the weights
plt.figure(figsize=(10, 8))
sns.heatmap(weights, annot=false, cmap='viridis')
plt.title("neuron weights heatmap of the input layer")
plt.xlabel("input features (6)")
plt.ylabel("neurons from inputs to output")
plt.show()


def nn_predict_shallow(x):
    """prediction function of the neural network (log scale)."""
    df = pd.dataframe(x, columns=x)
    df_scaled = nn_preprocessor.transform(df)
    pred = nn_model_shallow.predict(df_scaled, verbose=0, batch_size=10_000).flatten()
    return np.log(pred)


nn_explainer = shap.kernelexplainer(nn_predict_shallow, data=x_bg)
shap_nn = nn_explainer.shap_values(x_explain, nsamples=30)

all_dep_plots(x, shap_nn, x_explain)


#
# let's add a second layer to our network:

import tensorflow as tf
from tensorflow import keras
from keras import layers
from keras.callbacks import earlystopping, reducelronplateau
from keras.optimizers import adam
cb = [earlystopping(patience=20), reducelronplateau(patience=5)]  # "callbacks" for training (see below)

# architecture: adding layers
inputs = keras.input(shape=(len(x),))            # here is the input layer

z = layers.dense(7, activation="tanh")(inputs)   # here is the new layer: 7 neurons, inputs are the input, and z is the output. use "tanh"

# for more layers, you can continue using z.     # here is a commented-out example:
# z = layers.dense(3, activation="tanh"))(z)     # this is another layer: 3 neurons, z is the input, and z is the output

outputs = layers.dense(1, activation="exponential")(z)   # here, we convert the previous layer's results (z) into the overall output
nn_model_2layer = keras.model(inputs=inputs, outputs=outputs)   # the final layer often uses a different activation function

nn_model_2layer.summary()

nn_model_2layer.compile(optimizer=adam(learning_rate=1e-4), loss="poisson")


tf.random.set_seed(4349)

history_2layer = nn_model_2layer.fit(
    x=x_train,
    y=train[y],
    epochs=200,
    batch_size=10_000,
    validation_split=0.1,
    callbacks=cb,
    verbose=1,         # consider running both values 0 (no printing) and 1 (printing)
)


import seaborn as sns
import matplotlib.pyplot as plt

weights = nn_model_2layer.layers[1].get_weights()[0]  # get weights from this layer (omit the intercept, which is [1])
weights = np.transpose(weights)

# create a heatmap of the weights
plt.figure(figsize=(10, 8))
sns.heatmap(weights, annot=false, cmap='viridis')
plt.title("neuron weights heatmap of the input layer")
plt.xlabel(f"input features (6)")
plt.ylabel("neurons from inputs to layer1 (7)")
plt.show()



# next layer
weights = nn_model_2layer.layers[2].get_weights()[0]  # get weights from this layer (omit the intercept, which is [1])
weights = np.transpose(weights)

# create a heatmap of the weights
plt.figure(figsize=(10, 8))
sns.heatmap(weights, annot=false, cmap='viridis')
plt.title("neuron weights heatmap of next layer")
plt.xlabel("neurons from layer 1 (of 7)")
plt.ylabel("neurons from layer 1 to layer 2 (of 1)")
plt.show()



def nn_predict_2layer(x):
    """prediction function of the neural network (log scale)."""
    df = pd.dataframe(x, columns=x)
    df_scaled = nn_preprocessor.transform(df)
    pred = nn_model_2layer.predict(df_scaled, verbose=0, batch_size=10_000).flatten()
    return np.log(pred)

nn_explainer = shap.kernelexplainer(nn_predict_2layer, data=x_bg)
shap_nn = nn_explainer.shap_values(x_explain, nsamples=30)

all_dep_plots(x, shap_nn, x_explain)   # create all feature-dependency plots


#
# the age is a much more complicated - non-linear - feature
def age_effect(age):
    x = (age - 66) / 60
    return 0.05 + x**8 + 0.4 * x**3 + 0.3 * x**2 + 0.06 * x

#
# here is the true model for this dataset:
def true_model(x):
    """returns pd.series of true expected frequencies."""
    df = pd.dataframe(x, columns=x)  # needed because shap turns df to np.array
    log_lambda = (
        0.15 * df.town
        + np.log(age_effect(df.driver_age))
        + (0.3 + 0.15 * df.town) * df.car_power / 100
        - 0.02 * df.car_age
    )
    return np.exp(log_lambda)


import shap

true_model_explainer = shap.kernelexplainer(lambda x: np.log(true_model(x)), data=x_bg)
shap_true = true_model_explainer.shap_values(x_explain, nsamples=30)

all_dep_plots(x, shap_true, x_explain)


#

import tensorflow as tf
from tensorflow import keras
from keras import layers
from keras.callbacks import earlystopping, reducelronplateau
from keras.optimizers import adam
cb = [earlystopping(patience=20), reducelronplateau(patience=5)]  # "callbacks" for training (see below)

inputs = keras.input(shape=(len(x),))

#  more neurons! 
z = layers.dense(24, activation="relu")(inputs) 

z = layers.dense(12, activation="relu")(z)

z = layers.dense(6, activation="relu")(z)  

# output layer - keep exponential activation for poisson distribution
outputs = layers.dense(1, activation="exponential")(z)
nn_model_stepdown = keras.model(inputs=inputs, outputs=outputs)

nn_model_stepdown.summary()

nn_model_stepdown.compile(optimizer=adam(learning_rate=2e-4), loss="poisson")


history_stepdown = nn_model_stepdown.fit(
    x=x_train,
    y=train[y],
    epochs=200,
    batch_size=10_000,
    validation_split=0.1,
    callbacks=cb,
    verbose=1
)


def nn_predict_stepdown(x):
    """prediction function of the step-down neural network (log scale)."""
    df = pd.dataframe(x, columns=x)
    df_scaled = nn_preprocessor.transform(df)
    pred = nn_model_stepdown.predict(df_scaled, verbose=0, batch_size=10_000).flatten()
    return np.log(pred)

# create the explainer
nn_stepdown_explainer = shap.kernelexplainer(nn_predict_stepdown, data=x_bg)

# calculate shap values (this may take a while for deeper networks)
shap_nn_stepdown = nn_stepdown_explainer.shap_values(x_explain, nsamples=30)

# plot dependency plots using the existing function
all_dep_plots(x, shap_nn_stepdown, x_explain)


# training history plot

# after training the model
plt.figure(figsize=(12, 4))
plt.subplot(1, 2, 1)
plt.plot(history_stepdown.history['loss'], label='training loss')
plt.plot(history_stepdown.history['val_loss'], label='validation loss')
plt.title('loss curves')
plt.xlabel('epoch')
plt.ylabel('loss')
plt.legend()

if 'lr' in history_stepdown.history:
    plt.subplot(1, 2, 2)
    plt.plot(history_stepdown.history['lr'])
    plt.title('learning rate')
    plt.xlabel('epoch')
    plt.ylabel('learning rate')
    
plt.tight_layout()
plt.show()


# prediction vs actual

# test set predictions
x_test = nn_preprocessor.transform(test[x])
y_pred = nn_model_stepdown.predict(x_test, verbose=0).flatten()
y_true = test[y].values

# simple metrics
mean_abs_error = np.mean(np.abs(y_pred - y_true))
mean_squared_error = np.mean((y_pred - y_true)**2)
print(f"mean absolute error: {mean_abs_error:.4f}")
print(f"mean squared error: {mean_squared_error:.4f}")

# plot prediction distribution
plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.hist(y_true, bins=10, alpha=0.5, label='actual')
plt.hist(y_pred, bins=10, alpha=0.5, label='predicted')
plt.legend()
plt.title('distribution comparison')

plt.subplot(1, 2, 2)
plt.scatter(y_true, y_pred, alpha=0.3)
plt.plot([0, max(y_true)], [0, max(y_true)], 'r--')
plt.xlabel('actual')
plt.ylabel('predicted')
plt.title('actual vs predicted')
plt.tight_layout()
plt.show()


# attempt after many iterations

#

import tensorflow as tf
from tensorflow import keras
from keras import layers
from keras.callbacks import earlystopping, reducelronplateau
from keras.optimizers import adam
cb = [earlystopping(patience=20), reducelronplateau(patience=5)]

inputs = keras.input(shape=(len(x),))


z = layers.dense(24)(inputs)  
z = layers.leakyrelu(alpha=0.1)(z)  
z = layers.dropout(0.25)(z) 

# second layer
z = layers.dense(12)(z)
z = layers.leakyrelu(alpha=0.1)(z)

# third layer
z = layers.dense(6)(z)        
z = layers.leakyrelu(alpha=0.1)(z)

# output layer
outputs = layers.dense(1, activation="exponential")(z)
nn_model_improved = keras.model(inputs=inputs, outputs=outputs)

nn_model_improved.summary()

# keep same learning rate
nn_model_improved.compile(optimizer=adam(learning_rate=2e-4), loss="poisson")


history_improved = nn_model_improved.fit(
    x=x_train,
    y=train[y],
    epochs=200,
    batch_size=5000,
    validation_split=0.1,
    callbacks=cb,
    verbose=1
)

# plot training history
plt.figure(figsize=(12, 4))
plt.plot(history_improved.history['loss'], label='training loss')
plt.plot(history_improved.history['val_loss'], label='validation loss')
plt.title('loss curves')
plt.xlabel('epoch')
plt.ylabel('loss')
plt.legend()
plt.show()

# evaluation on test set
x_test = nn_preprocessor.transform(test[x])
y_pred = nn_model_improved.predict(x_test, verbose=0).flatten()
y_true = test[y].values

# metrics
mean_abs_error = np.mean(np.abs(y_pred - y_true))
mean_squared_error = np.mean((y_pred - y_true)**2)
print(f"mean absolute error: {mean_abs_error:.4f}")
print(f"mean squared error: {mean_squared_error:.4f}")

# visualization
plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.hist(y_true, bins=10, alpha=0.5, label='actual')
plt.hist(y_pred, bins=10, alpha=0.5, label='predicted')
plt.legend()
plt.title('distribution comparison')

plt.subplot(1, 2, 2)
plt.scatter(y_true, y_pred, alpha=0.3)
plt.plot([0, max(y_true)], [0, max(y_true)], 'r--')
plt.xlabel('actual')
plt.ylabel('predicted')
plt.title('actual vs predicted')
plt.tight_layout()
plt.show()

# shap analysis
def nn_predict_improved(x):
    """prediction function of the improved neural network (log scale)."""
    df = pd.dataframe(x, columns=x)
    df_scaled = nn_preprocessor.transform(df)
    pred = nn_model_improved.predict(df_scaled, verbose=0, batch_size=10_000).flatten()
    return np.log(pred)

# create explainer
nn_improved_explainer = shap.kernelexplainer(nn_predict_improved, data=x_bg)
shap_nn_improved = nn_improved_explainer.shap_values(x_explain, nsamples=30)

# plot dependency plots
all_dep_plots(x, shap_nn_improved, x_explain)

# feature importance summary
feature_importance = np.abs(shap_nn_improved).mean(0)
features_df = pd.dataframe(list(zip(x, feature_importance)), columns=['feature', 'importance'])
features_df = features_df.sort_values('importance', ascending=false)
print("feature importance:")
print(features_df)


